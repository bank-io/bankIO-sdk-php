<?php
/**
 * AccountInformationServiceAISApi
 * PHP version 7.2
 *
 * @category Class
 * @package  BankIO\Sdk
 * @author   bankIO
 * @link     https://bankio.co.uk/bankio-link/
 */

/**
 * bankIO NextGenPSD2 XS2A Framework
 *
 * # Summary The **NextGenPSD2** *Framework Version 1.3.6* (with errata) offers a modern, open, harmonised and interoperable set of Application Programming Interfaces (APIs) as the safest and most efficient way to provide data securely. The NextGenPSD2 Framework reduces XS2A complexity and costs, addresses the problem of multiple competing standards  in Europe and, aligned with the goals of the Euro Retail Payments Board, enables European banking customers to benefit from innovative products and services ('Banking as a Service') by granting TPPs safe and secure (authenticated and authorised) access to their bank accounts and financial data.  The possible Approaches are:   * Redirect SCA Approach   * OAuth SCA Approach   * Decoupled SCA Approach   * Embedded SCA Approach without SCA method   * Embedded SCA Approach with only one SCA method available   * Embedded SCA Approach with Selection of a SCA method    Not every message defined in this API definition is necessary for all approaches.    Furthermore this API definition does not differ between methods which are mandatory, conditional, or optional.   Therefore for a particular implementation of a Berlin Group PSD2 compliant API it is only necessary to support    a certain subset of the methods defined in this API definition.    **Please have a look at the implementation guidelines if you are not sure    which message has to be used for the approach you are going to use.**  ## Some General Remarks Related to this version of the OpenAPI Specification: * **This API definition is based on the Implementation Guidelines of the Berlin Group PSD2 API.**    It is not a replacement in any sense.   The main specification is (at the moment) always the Implementation Guidelines of the Berlin Group PSD2 API. * **This API definition contains the REST-API for requests from the PISP to the ASPSP.** * **This API definition contains the messages for all different approaches defined in the Implementation Guidelines.** * According to the OpenAPI-Specification [https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md]        \"If in is \"header\" and the name field is \"Accept\", \"Content-Type\" or \"Authorization\", the parameter definition SHALL be ignored.\"      The element \"Accept\" will not be defined in this file at any place.      The elements \"Content-Type\" and \"Authorization\" are implicitly defined by the OpenApi tags \"content\" and \"security\".    * There are several predefined types which might occur in payment initiation messages,    but are not used in the standard JSON messages in the Implementation Guidelines.   Therefore they are not used in the corresponding messages in this file either.   We added them for the convenience of the user.   If there is a payment product, which needs these fields, one can easily use the predefined types.   But the ASPSP need not to accept them in general.    * **We omit the definition of all standard HTTP header elements (mandatory/optional/conditional)    except they are mentioned in the Implementation Guidelines.**   Therefore the implementer might add these in his own realisation of a PSD2 comlient API in addition to the elements defined in this file.     ## General Remarks on Data Types  The Berlin Group definition of UTF-8 strings in context of the PSD2 API has to support at least the following characters  a b c d e f g h i j k l m n o p q r s t u v w x y z  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z  0 1 2 3 4 5 6 7 8 9  / - ? : ( ) . , ' +  Space
 *
 * The version of the OpenAPI document: 1.3.6_2020-05-28
 * Contact: hello@bankio.co.uk
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace BankIO\Sdk\Api;

use Http\Client\HttpClient;
use Http\Client\HttpAsyncClient;
use Http\Message\MessageFactory;
use Http\Discovery\HttpClientDiscovery;
use Http\Discovery\HttpAsyncClientDiscovery;
use Http\Discovery\MessageFactoryDiscovery;
use Http\Discovery\StreamFactoryDiscovery;
use Http\Client\Exception\NetworkException;
use Http\Client\Exception\HttpException;
use Http\Message\StreamFactory;
use Http\Message\MultipartStream\MultipartStreamBuilder;
use Psr\Http\Message\RequestInterface;
use BankIO\Sdk\ApiException;
use BankIO\Sdk\Configuration;
use BankIO\Sdk\HeaderSelector;
use BankIO\Sdk\ObjectSerializer;

/**
 * AccountInformationServiceAISApi Class Doc Comment
 *
 * @category Class
 * @package  BankIO\Sdk
 * @author   bankIO
 * @link     https://bankio.co.uk/bankio-link/
 */
class AccountInformationServiceAISApi
{
    /**
     * @var HttpClient
     */
    protected $client;

    /**
     * @var HttpAsyncClient
     */
    protected $asyncClient;

    /**
     * @var MessageFactory
     */
    protected $messageFactory;

    /**
     * @var StreamFactory
     */
    protected $streamFactory;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param HttpClient $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        HttpClient $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        MessageFactory $messageFactory = null,
        StreamFactory $streamFactory = null,
        $host_index = 0
    ) {
        $this->client = $client ?: HttpClientDiscovery::find();
        // $this->asyncClient = $asyncClient ?: HttpAsyncClientDiscovery::find();
        $this->messageFactory = $messageFactory ?: MessageFactoryDiscovery::find();
        $this->streamFactory = $streamFactory ?: StreamFactoryDiscovery::find();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createConsent
     *
     * Create consent
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $tpp_psu_id Client ID of the PSU in the TPP client interface.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. (required)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. If not available, the TPP shall use the IP Address used by the TPP when submitting this request. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  bool $tpp_explicit_authorisation_preferred If it equals \&quot;true\&quot;, the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \&quot;false\&quot; or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket. (optional)
     * @param  string $tpp_brand_logging_information This header might be used by TPPs to inform the ASPSP about the brand used by the TPP towards the PSU.  This information is meant for logging entries to enhance communication between ASPSP and PSU or ASPSP and TPP.  This header might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\Consents $consents Request body for a consents request. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\ConsentsResponse201|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS
     */
    public function createConsent($associative_array)
    {
        list($response) = $this->createConsentWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation createConsentWithHttpInfo
     *
     * Create consent
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $tpp_psu_id Client ID of the PSU in the TPP client interface.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. (required)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. If not available, the TPP shall use the IP Address used by the TPP when submitting this request. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  bool $tpp_explicit_authorisation_preferred If it equals \&quot;true\&quot;, the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \&quot;false\&quot; or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket. (optional)
     * @param  string $tpp_brand_logging_information This header might be used by TPPs to inform the ASPSP about the brand used by the TPP towards the PSU.  This information is meant for logging entries to enhance communication between ASPSP and PSU or ASPSP and TPP.  This header might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\Consents $consents Request body for a consents request. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\ConsentsResponse201|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConsentWithHttpInfo($associative_array)
    {
        $request = $this->createConsentRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 201:
                    if ('\BankIO\Sdk\Model\ConsentsResponse201' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\ConsentsResponse201', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\BankIO\Sdk\Model\Error406NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error406NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BankIO\Sdk\Model\Error429NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error429NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\ConsentsResponse201';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\ConsentsResponse201',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createConsentAsync
     *
     * Create consent
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $tpp_psu_id Client ID of the PSU in the TPP client interface.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. (required)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. If not available, the TPP shall use the IP Address used by the TPP when submitting this request. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  bool $tpp_explicit_authorisation_preferred If it equals \&quot;true\&quot;, the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \&quot;false\&quot; or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket. (optional)
     * @param  string $tpp_brand_logging_information This header might be used by TPPs to inform the ASPSP about the brand used by the TPP towards the PSU.  This information is meant for logging entries to enhance communication between ASPSP and PSU or ASPSP and TPP.  This header might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\Consents $consents Request body for a consents request. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function createConsentAsync($associative_array)
    {
        return $this->createConsentAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConsentAsyncWithHttpInfo
     *
     * Create consent
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $tpp_psu_id Client ID of the PSU in the TPP client interface.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. (required)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. If not available, the TPP shall use the IP Address used by the TPP when submitting this request. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  bool $tpp_explicit_authorisation_preferred If it equals \&quot;true\&quot;, the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \&quot;false\&quot; or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket. (optional)
     * @param  string $tpp_brand_logging_information This header might be used by TPPs to inform the ASPSP about the brand used by the TPP towards the PSU.  This information is meant for logging entries to enhance communication between ASPSP and PSU or ASPSP and TPP.  This header might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\Consents $consents Request body for a consents request. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function createConsentAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\ConsentsResponse201';
        $request = $this->createConsentRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConsent'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $tpp_psu_id Client ID of the PSU in the TPP client interface.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. (required)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. If not available, the TPP shall use the IP Address used by the TPP when submitting this request. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  bool $tpp_explicit_authorisation_preferred If it equals \&quot;true\&quot;, the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \&quot;false\&quot; or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket. (optional)
     * @param  string $tpp_brand_logging_information This header might be used by TPPs to inform the ASPSP about the brand used by the TPP towards the PSU.  This information is meant for logging entries to enhance communication between ASPSP and PSU or ASPSP and TPP.  This header might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\Consents $consents Request body for a consents request. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function createConsentRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $tpp_psu_id = array_key_exists('tpp_psu_id', $associative_array) ? $associative_array['tpp_psu_id'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_id = array_key_exists('psu_id', $associative_array) ? $associative_array['psu_id'] : null;
        $psu_id_type = array_key_exists('psu_id_type', $associative_array) ? $associative_array['psu_id_type'] : null;
        $psu_corporate_id = array_key_exists('psu_corporate_id', $associative_array) ? $associative_array['psu_corporate_id'] : null;
        $psu_corporate_id_type = array_key_exists('psu_corporate_id_type', $associative_array) ? $associative_array['psu_corporate_id_type'] : null;
        $tpp_redirect_preferred = array_key_exists('tpp_redirect_preferred', $associative_array) ? $associative_array['tpp_redirect_preferred'] : null;
        $tpp_redirect_uri = array_key_exists('tpp_redirect_uri', $associative_array) ? $associative_array['tpp_redirect_uri'] : null;
        $tpp_nok_redirect_uri = array_key_exists('tpp_nok_redirect_uri', $associative_array) ? $associative_array['tpp_nok_redirect_uri'] : null;
        $tpp_explicit_authorisation_preferred = array_key_exists('tpp_explicit_authorisation_preferred', $associative_array) ? $associative_array['tpp_explicit_authorisation_preferred'] : null;
        $tpp_brand_logging_information = array_key_exists('tpp_brand_logging_information', $associative_array) ? $associative_array['tpp_brand_logging_information'] : null;
        $tpp_notification_uri = array_key_exists('tpp_notification_uri', $associative_array) ? $associative_array['tpp_notification_uri'] : null;
        $tpp_notification_content_preferred = array_key_exists('tpp_notification_content_preferred', $associative_array) ? $associative_array['tpp_notification_content_preferred'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;
        $consents = array_key_exists('consents', $associative_array) ? $associative_array['consents'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling createConsent'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling createConsent'
            );
        }
        // verify the required parameter 'tpp_psu_id' is set
        if ($tpp_psu_id === null || (is_array($tpp_psu_id) && count($tpp_psu_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tpp_psu_id when calling createConsent'
            );
        }
        // verify the required parameter 'psu_ip_address' is set
        if ($psu_ip_address === null || (is_array($psu_ip_address) && count($psu_ip_address) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $psu_ip_address when calling createConsent'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.createConsent, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/consents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($tpp_psu_id !== null) {
            $headerParams['TPP-PSU-ID'] = ObjectSerializer::toHeaderValue($tpp_psu_id);
        }
        // header params
        if ($psu_id !== null) {
            $headerParams['PSU-ID'] = ObjectSerializer::toHeaderValue($psu_id);
        }
        // header params
        if ($psu_id_type !== null) {
            $headerParams['PSU-ID-Type'] = ObjectSerializer::toHeaderValue($psu_id_type);
        }
        // header params
        if ($psu_corporate_id !== null) {
            $headerParams['PSU-Corporate-ID'] = ObjectSerializer::toHeaderValue($psu_corporate_id);
        }
        // header params
        if ($psu_corporate_id_type !== null) {
            $headerParams['PSU-Corporate-ID-Type'] = ObjectSerializer::toHeaderValue($psu_corporate_id_type);
        }
        // header params
        if ($tpp_redirect_preferred !== null) {
            $headerParams['TPP-Redirect-Preferred'] = ObjectSerializer::toHeaderValue($tpp_redirect_preferred);
        }
        // header params
        if ($tpp_redirect_uri !== null) {
            $headerParams['TPP-Redirect-URI'] = ObjectSerializer::toHeaderValue($tpp_redirect_uri);
        }
        // header params
        if ($tpp_nok_redirect_uri !== null) {
            $headerParams['TPP-Nok-Redirect-URI'] = ObjectSerializer::toHeaderValue($tpp_nok_redirect_uri);
        }
        // header params
        if ($tpp_explicit_authorisation_preferred !== null) {
            $headerParams['TPP-Explicit-Authorisation-Preferred'] = ObjectSerializer::toHeaderValue($tpp_explicit_authorisation_preferred);
        }
        // header params
        if ($tpp_brand_logging_information !== null) {
            $headerParams['TPP-Brand-Logging-Information'] = ObjectSerializer::toHeaderValue($tpp_brand_logging_information);
        }
        // header params
        if ($tpp_notification_uri !== null) {
            $headerParams['TPP-Notification-URI'] = ObjectSerializer::toHeaderValue($tpp_notification_uri);
        }
        // header params
        if ($tpp_notification_content_preferred !== null) {
            $headerParams['TPP-Notification-Content-Preferred'] = ObjectSerializer::toHeaderValue($tpp_notification_content_preferred);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($consents)) {
            $_tempBody = $consents;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteConsent
     *
     * Delete consent
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteConsent($associative_array)
    {
        $this->deleteConsentWithHttpInfo($associative_array);
    }

    /**
     * Operation deleteConsentWithHttpInfo
     *
     * Delete consent
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteConsentWithHttpInfo($associative_array)
    {
        $request = $this->deleteConsentRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteConsentAsync
     *
     * Delete consent
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function deleteConsentAsync($associative_array)
    {
        return $this->deleteConsentAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteConsentAsyncWithHttpInfo
     *
     * Delete consent
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function deleteConsentAsyncWithHttpInfo($associative_array)
    {
        $returnType = '';
        $request = $this->deleteConsentRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteConsent'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function deleteConsentRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $consent_id = array_key_exists('consent_id', $associative_array) ? $associative_array['consent_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling deleteConsent'
            );
        }
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling deleteConsent'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling deleteConsent'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.deleteConsent, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/consents/{consentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccountList
     *
     * Read account list
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\AccountList|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS
     */
    public function getAccountList($associative_array)
    {
        list($response) = $this->getAccountListWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getAccountListWithHttpInfo
     *
     * Read account list
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\AccountList|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccountListWithHttpInfo($associative_array)
    {
        $request = $this->getAccountListRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\AccountList' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\AccountList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\BankIO\Sdk\Model\Error406NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error406NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BankIO\Sdk\Model\Error429NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error429NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\AccountList';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\AccountList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccountListAsync
     *
     * Read account list
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getAccountListAsync($associative_array)
    {
        return $this->getAccountListAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccountListAsyncWithHttpInfo
     *
     * Read account list
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getAccountListAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\AccountList';
        $request = $this->getAccountListRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccountList'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getAccountListRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $consent_id = array_key_exists('consent_id', $associative_array) ? $associative_array['consent_id'] : null;
        $with_balance = array_key_exists('with_balance', $associative_array) ? $associative_array['with_balance'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getAccountList'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getAccountList'
            );
        }
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getAccountList'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.getAccountList, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with_balance !== null) {
            if('form' === 'form' && is_array($with_balance)) {
                foreach($with_balance as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withBalance'] = $with_balance;
            }
        }

        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($consent_id !== null) {
            $headerParams['Consent-ID'] = ObjectSerializer::toHeaderValue($consent_id);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBalances
     *
     * Read balance
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\ReadAccountBalanceResponse200|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS
     */
    public function getBalances($associative_array)
    {
        list($response) = $this->getBalancesWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getBalancesWithHttpInfo
     *
     * Read balance
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\ReadAccountBalanceResponse200|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBalancesWithHttpInfo($associative_array)
    {
        $request = $this->getBalancesRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\ReadAccountBalanceResponse200' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\ReadAccountBalanceResponse200', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\BankIO\Sdk\Model\Error406NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error406NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BankIO\Sdk\Model\Error429NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error429NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\ReadAccountBalanceResponse200';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\ReadAccountBalanceResponse200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBalancesAsync
     *
     * Read balance
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getBalancesAsync($associative_array)
    {
        return $this->getBalancesAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBalancesAsyncWithHttpInfo
     *
     * Read balance
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getBalancesAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\ReadAccountBalanceResponse200';
        $request = $this->getBalancesRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBalances'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getBalancesRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $account_id = array_key_exists('account_id', $associative_array) ? $associative_array['account_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $consent_id = array_key_exists('consent_id', $associative_array) ? $associative_array['consent_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getBalances'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getBalances'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getBalances'
            );
        }
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getBalances'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.getBalances, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/accounts/{account-id}/balances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($consent_id !== null) {
            $headerParams['Consent-ID'] = ObjectSerializer::toHeaderValue($consent_id);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'account-id' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCardAccount
     *
     * Read a list of card accounts
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\CardAccountList|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS
     */
    public function getCardAccount($associative_array)
    {
        list($response) = $this->getCardAccountWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getCardAccountWithHttpInfo
     *
     * Read a list of card accounts
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\CardAccountList|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCardAccountWithHttpInfo($associative_array)
    {
        $request = $this->getCardAccountRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\CardAccountList' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\CardAccountList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\BankIO\Sdk\Model\Error406NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error406NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BankIO\Sdk\Model\Error429NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error429NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\CardAccountList';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\CardAccountList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCardAccountAsync
     *
     * Read a list of card accounts
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getCardAccountAsync($associative_array)
    {
        return $this->getCardAccountAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCardAccountAsyncWithHttpInfo
     *
     * Read a list of card accounts
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getCardAccountAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\CardAccountList';
        $request = $this->getCardAccountRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCardAccount'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getCardAccountRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $consent_id = array_key_exists('consent_id', $associative_array) ? $associative_array['consent_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getCardAccount'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getCardAccount'
            );
        }
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getCardAccount'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.getCardAccount, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/card-accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($consent_id !== null) {
            $headerParams['Consent-ID'] = ObjectSerializer::toHeaderValue($consent_id);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCardAccountBalances
     *
     * Read card account balances
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\ReadCardAccountBalanceResponse200|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS
     */
    public function getCardAccountBalances($associative_array)
    {
        list($response) = $this->getCardAccountBalancesWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getCardAccountBalancesWithHttpInfo
     *
     * Read card account balances
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\ReadCardAccountBalanceResponse200|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCardAccountBalancesWithHttpInfo($associative_array)
    {
        $request = $this->getCardAccountBalancesRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\ReadCardAccountBalanceResponse200' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\ReadCardAccountBalanceResponse200', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\BankIO\Sdk\Model\Error406NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error406NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BankIO\Sdk\Model\Error429NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error429NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\ReadCardAccountBalanceResponse200';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\ReadCardAccountBalanceResponse200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCardAccountBalancesAsync
     *
     * Read card account balances
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getCardAccountBalancesAsync($associative_array)
    {
        return $this->getCardAccountBalancesAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCardAccountBalancesAsyncWithHttpInfo
     *
     * Read card account balances
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getCardAccountBalancesAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\ReadCardAccountBalanceResponse200';
        $request = $this->getCardAccountBalancesRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCardAccountBalances'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getCardAccountBalancesRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $account_id = array_key_exists('account_id', $associative_array) ? $associative_array['account_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $consent_id = array_key_exists('consent_id', $associative_array) ? $associative_array['consent_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getCardAccountBalances'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getCardAccountBalances'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getCardAccountBalances'
            );
        }
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getCardAccountBalances'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.getCardAccountBalances, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/card-accounts/{account-id}/balances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($consent_id !== null) {
            $headerParams['Consent-ID'] = ObjectSerializer::toHeaderValue($consent_id);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'account-id' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCardAccountTransactionList
     *
     * Read transaction list of an account
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $booking_status Permitted codes are    * \&quot;information\&quot;,   * \&quot;booked\&quot;,   * \&quot;pending\&quot;, and    * \&quot;both\&quot; \&quot;booked\&quot; shall be supported by the ASPSP. To support the \&quot;pending\&quot; and \&quot;both\&quot; feature is optional for the ASPSP,  Error code if not supported in the online banking frontend (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  \DateTime $date_from Conditional: Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required and if bookingStatus does not equal \&quot;information.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  \DateTime $date_to End date (inclusive the data dateTo) of the transaction list, default is \&quot;now\&quot; if not given.   Might be ignored if a delta function is used.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  string $entry_reference_from This data attribute is indicating that the AISP is in favour to get all transactions after  the transaction with identification entryReferenceFrom alternatively to the above defined period.  This is a implementation of a delta access.  If this data element is contained, the entries \&quot;dateFrom\&quot; and \&quot;dateTo\&quot; might be ignored by the ASPSP  if a delta report is supported.  Optional if supported by API provider. (optional)
     * @param  bool $delta_list This data attribute is indicating that the AISP is in favour to get all transactions after the last report access for this PSU on the addressed account. This is another implementation of a delta access-report. This delta indicator might be rejected by the ASPSP if this function is not supported. Optional if supported by API provider (optional)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\CardAccountsTransactionsResponse200|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS
     */
    public function getCardAccountTransactionList($associative_array)
    {
        list($response) = $this->getCardAccountTransactionListWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getCardAccountTransactionListWithHttpInfo
     *
     * Read transaction list of an account
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $booking_status Permitted codes are    * \&quot;information\&quot;,   * \&quot;booked\&quot;,   * \&quot;pending\&quot;, and    * \&quot;both\&quot; \&quot;booked\&quot; shall be supported by the ASPSP. To support the \&quot;pending\&quot; and \&quot;both\&quot; feature is optional for the ASPSP,  Error code if not supported in the online banking frontend (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  \DateTime $date_from Conditional: Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required and if bookingStatus does not equal \&quot;information.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  \DateTime $date_to End date (inclusive the data dateTo) of the transaction list, default is \&quot;now\&quot; if not given.   Might be ignored if a delta function is used.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  string $entry_reference_from This data attribute is indicating that the AISP is in favour to get all transactions after  the transaction with identification entryReferenceFrom alternatively to the above defined period.  This is a implementation of a delta access.  If this data element is contained, the entries \&quot;dateFrom\&quot; and \&quot;dateTo\&quot; might be ignored by the ASPSP  if a delta report is supported.  Optional if supported by API provider. (optional)
     * @param  bool $delta_list This data attribute is indicating that the AISP is in favour to get all transactions after the last report access for this PSU on the addressed account. This is another implementation of a delta access-report. This delta indicator might be rejected by the ASPSP if this function is not supported. Optional if supported by API provider (optional)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\CardAccountsTransactionsResponse200|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCardAccountTransactionListWithHttpInfo($associative_array)
    {
        $request = $this->getCardAccountTransactionListRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\CardAccountsTransactionsResponse200' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\CardAccountsTransactionsResponse200', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\BankIO\Sdk\Model\Error406NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error406NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BankIO\Sdk\Model\Error429NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error429NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\CardAccountsTransactionsResponse200';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\CardAccountsTransactionsResponse200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCardAccountTransactionListAsync
     *
     * Read transaction list of an account
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $booking_status Permitted codes are    * \&quot;information\&quot;,   * \&quot;booked\&quot;,   * \&quot;pending\&quot;, and    * \&quot;both\&quot; \&quot;booked\&quot; shall be supported by the ASPSP. To support the \&quot;pending\&quot; and \&quot;both\&quot; feature is optional for the ASPSP,  Error code if not supported in the online banking frontend (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  \DateTime $date_from Conditional: Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required and if bookingStatus does not equal \&quot;information.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  \DateTime $date_to End date (inclusive the data dateTo) of the transaction list, default is \&quot;now\&quot; if not given.   Might be ignored if a delta function is used.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  string $entry_reference_from This data attribute is indicating that the AISP is in favour to get all transactions after  the transaction with identification entryReferenceFrom alternatively to the above defined period.  This is a implementation of a delta access.  If this data element is contained, the entries \&quot;dateFrom\&quot; and \&quot;dateTo\&quot; might be ignored by the ASPSP  if a delta report is supported.  Optional if supported by API provider. (optional)
     * @param  bool $delta_list This data attribute is indicating that the AISP is in favour to get all transactions after the last report access for this PSU on the addressed account. This is another implementation of a delta access-report. This delta indicator might be rejected by the ASPSP if this function is not supported. Optional if supported by API provider (optional)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getCardAccountTransactionListAsync($associative_array)
    {
        return $this->getCardAccountTransactionListAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCardAccountTransactionListAsyncWithHttpInfo
     *
     * Read transaction list of an account
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $booking_status Permitted codes are    * \&quot;information\&quot;,   * \&quot;booked\&quot;,   * \&quot;pending\&quot;, and    * \&quot;both\&quot; \&quot;booked\&quot; shall be supported by the ASPSP. To support the \&quot;pending\&quot; and \&quot;both\&quot; feature is optional for the ASPSP,  Error code if not supported in the online banking frontend (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  \DateTime $date_from Conditional: Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required and if bookingStatus does not equal \&quot;information.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  \DateTime $date_to End date (inclusive the data dateTo) of the transaction list, default is \&quot;now\&quot; if not given.   Might be ignored if a delta function is used.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  string $entry_reference_from This data attribute is indicating that the AISP is in favour to get all transactions after  the transaction with identification entryReferenceFrom alternatively to the above defined period.  This is a implementation of a delta access.  If this data element is contained, the entries \&quot;dateFrom\&quot; and \&quot;dateTo\&quot; might be ignored by the ASPSP  if a delta report is supported.  Optional if supported by API provider. (optional)
     * @param  bool $delta_list This data attribute is indicating that the AISP is in favour to get all transactions after the last report access for this PSU on the addressed account. This is another implementation of a delta access-report. This delta indicator might be rejected by the ASPSP if this function is not supported. Optional if supported by API provider (optional)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getCardAccountTransactionListAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\CardAccountsTransactionsResponse200';
        $request = $this->getCardAccountTransactionListRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCardAccountTransactionList'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $booking_status Permitted codes are    * \&quot;information\&quot;,   * \&quot;booked\&quot;,   * \&quot;pending\&quot;, and    * \&quot;both\&quot; \&quot;booked\&quot; shall be supported by the ASPSP. To support the \&quot;pending\&quot; and \&quot;both\&quot; feature is optional for the ASPSP,  Error code if not supported in the online banking frontend (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  \DateTime $date_from Conditional: Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required and if bookingStatus does not equal \&quot;information.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  \DateTime $date_to End date (inclusive the data dateTo) of the transaction list, default is \&quot;now\&quot; if not given.   Might be ignored if a delta function is used.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  string $entry_reference_from This data attribute is indicating that the AISP is in favour to get all transactions after  the transaction with identification entryReferenceFrom alternatively to the above defined period.  This is a implementation of a delta access.  If this data element is contained, the entries \&quot;dateFrom\&quot; and \&quot;dateTo\&quot; might be ignored by the ASPSP  if a delta report is supported.  Optional if supported by API provider. (optional)
     * @param  bool $delta_list This data attribute is indicating that the AISP is in favour to get all transactions after the last report access for this PSU on the addressed account. This is another implementation of a delta access-report. This delta indicator might be rejected by the ASPSP if this function is not supported. Optional if supported by API provider (optional)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getCardAccountTransactionListRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $account_id = array_key_exists('account_id', $associative_array) ? $associative_array['account_id'] : null;
        $booking_status = array_key_exists('booking_status', $associative_array) ? $associative_array['booking_status'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $consent_id = array_key_exists('consent_id', $associative_array) ? $associative_array['consent_id'] : null;
        $date_from = array_key_exists('date_from', $associative_array) ? $associative_array['date_from'] : null;
        $date_to = array_key_exists('date_to', $associative_array) ? $associative_array['date_to'] : null;
        $entry_reference_from = array_key_exists('entry_reference_from', $associative_array) ? $associative_array['entry_reference_from'] : null;
        $delta_list = array_key_exists('delta_list', $associative_array) ? $associative_array['delta_list'] : null;
        $with_balance = array_key_exists('with_balance', $associative_array) ? $associative_array['with_balance'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getCardAccountTransactionList'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getCardAccountTransactionList'
            );
        }
        // verify the required parameter 'booking_status' is set
        if ($booking_status === null || (is_array($booking_status) && count($booking_status) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $booking_status when calling getCardAccountTransactionList'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getCardAccountTransactionList'
            );
        }
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getCardAccountTransactionList'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.getCardAccountTransactionList, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/card-accounts/{account-id}/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date_from !== null) {
            if('form' === 'form' && is_array($date_from)) {
                foreach($date_from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dateFrom'] = $date_from;
            }
        }
        // query params
        if ($date_to !== null) {
            if('form' === 'form' && is_array($date_to)) {
                foreach($date_to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dateTo'] = $date_to;
            }
        }
        // query params
        if ($entry_reference_from !== null) {
            if('form' === 'form' && is_array($entry_reference_from)) {
                foreach($entry_reference_from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['entryReferenceFrom'] = $entry_reference_from;
            }
        }
        // query params
        if ($booking_status !== null) {
            if('form' === 'form' && is_array($booking_status)) {
                foreach($booking_status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['bookingStatus'] = $booking_status;
            }
        }
        // query params
        if ($delta_list !== null) {
            if('form' === 'form' && is_array($delta_list)) {
                foreach($delta_list as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['deltaList'] = $delta_list;
            }
        }
        // query params
        if ($with_balance !== null) {
            if('form' === 'form' && is_array($with_balance)) {
                foreach($with_balance as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withBalance'] = $with_balance;
            }
        }

        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($consent_id !== null) {
            $headerParams['Consent-ID'] = ObjectSerializer::toHeaderValue($consent_id);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'account-id' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConsentAuthorisation
     *
     * Get consent authorisation sub-resources request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\Authorisations|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS
     */
    public function getConsentAuthorisation($associative_array)
    {
        list($response) = $this->getConsentAuthorisationWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getConsentAuthorisationWithHttpInfo
     *
     * Get consent authorisation sub-resources request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\Authorisations|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConsentAuthorisationWithHttpInfo($associative_array)
    {
        $request = $this->getConsentAuthorisationRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\Authorisations' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Authorisations', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\BankIO\Sdk\Model\Error406NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error406NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BankIO\Sdk\Model\Error429NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error429NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\Authorisations';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Authorisations',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConsentAuthorisationAsync
     *
     * Get consent authorisation sub-resources request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getConsentAuthorisationAsync($associative_array)
    {
        return $this->getConsentAuthorisationAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConsentAuthorisationAsyncWithHttpInfo
     *
     * Get consent authorisation sub-resources request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getConsentAuthorisationAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\Authorisations';
        $request = $this->getConsentAuthorisationRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConsentAuthorisation'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getConsentAuthorisationRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $consent_id = array_key_exists('consent_id', $associative_array) ? $associative_array['consent_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getConsentAuthorisation'
            );
        }
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getConsentAuthorisation'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getConsentAuthorisation'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.getConsentAuthorisation, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/consents/{consentId}/authorisations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConsentInformation
     *
     * Get consent request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\ConsentInformationResponse200Json|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS
     */
    public function getConsentInformation($associative_array)
    {
        list($response) = $this->getConsentInformationWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getConsentInformationWithHttpInfo
     *
     * Get consent request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\ConsentInformationResponse200Json|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConsentInformationWithHttpInfo($associative_array)
    {
        $request = $this->getConsentInformationRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\ConsentInformationResponse200Json' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\ConsentInformationResponse200Json', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\BankIO\Sdk\Model\Error406NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error406NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BankIO\Sdk\Model\Error429NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error429NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\ConsentInformationResponse200Json';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\ConsentInformationResponse200Json',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConsentInformationAsync
     *
     * Get consent request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getConsentInformationAsync($associative_array)
    {
        return $this->getConsentInformationAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConsentInformationAsyncWithHttpInfo
     *
     * Get consent request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getConsentInformationAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\ConsentInformationResponse200Json';
        $request = $this->getConsentInformationRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConsentInformation'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getConsentInformationRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $consent_id = array_key_exists('consent_id', $associative_array) ? $associative_array['consent_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getConsentInformation'
            );
        }
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getConsentInformation'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getConsentInformation'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.getConsentInformation, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/consents/{consentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConsentScaStatus
     *
     * Read the SCA status of the consent authorisation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\ScaStatusResponse|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS
     */
    public function getConsentScaStatus($associative_array)
    {
        list($response) = $this->getConsentScaStatusWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getConsentScaStatusWithHttpInfo
     *
     * Read the SCA status of the consent authorisation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\ScaStatusResponse|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConsentScaStatusWithHttpInfo($associative_array)
    {
        $request = $this->getConsentScaStatusRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\ScaStatusResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\ScaStatusResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\BankIO\Sdk\Model\Error406NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error406NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BankIO\Sdk\Model\Error429NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error429NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\ScaStatusResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\ScaStatusResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConsentScaStatusAsync
     *
     * Read the SCA status of the consent authorisation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getConsentScaStatusAsync($associative_array)
    {
        return $this->getConsentScaStatusAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConsentScaStatusAsyncWithHttpInfo
     *
     * Read the SCA status of the consent authorisation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getConsentScaStatusAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\ScaStatusResponse';
        $request = $this->getConsentScaStatusRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConsentScaStatus'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getConsentScaStatusRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $consent_id = array_key_exists('consent_id', $associative_array) ? $associative_array['consent_id'] : null;
        $authorisation_id = array_key_exists('authorisation_id', $associative_array) ? $associative_array['authorisation_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getConsentScaStatus'
            );
        }
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getConsentScaStatus'
            );
        }
        // verify the required parameter 'authorisation_id' is set
        if ($authorisation_id === null || (is_array($authorisation_id) && count($authorisation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorisation_id when calling getConsentScaStatus'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getConsentScaStatus'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.getConsentScaStatus, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/consents/{consentId}/authorisations/{authorisationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }
        // path params
        if ($authorisation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'authorisationId' . '}',
                ObjectSerializer::toPathValue($authorisation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConsentStatus
     *
     * Consent status request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\ConsentStatusResponse200|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS
     */
    public function getConsentStatus($associative_array)
    {
        list($response) = $this->getConsentStatusWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getConsentStatusWithHttpInfo
     *
     * Consent status request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\ConsentStatusResponse200|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConsentStatusWithHttpInfo($associative_array)
    {
        $request = $this->getConsentStatusRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\ConsentStatusResponse200' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\ConsentStatusResponse200', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\BankIO\Sdk\Model\Error406NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error406NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BankIO\Sdk\Model\Error429NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error429NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\ConsentStatusResponse200';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\ConsentStatusResponse200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConsentStatusAsync
     *
     * Consent status request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getConsentStatusAsync($associative_array)
    {
        return $this->getConsentStatusAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConsentStatusAsyncWithHttpInfo
     *
     * Consent status request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getConsentStatusAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\ConsentStatusResponse200';
        $request = $this->getConsentStatusRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConsentStatus'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getConsentStatusRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $consent_id = array_key_exists('consent_id', $associative_array) ? $associative_array['consent_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getConsentStatus'
            );
        }
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getConsentStatus'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getConsentStatus'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.getConsentStatus, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/consents/{consentId}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransactionDetails
     *
     * Read transaction details
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $transaction_id This identification is given by the attribute transactionId of the corresponding entry of a transaction list. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\InlineResponse2001|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS
     */
    public function getTransactionDetails($associative_array)
    {
        list($response) = $this->getTransactionDetailsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getTransactionDetailsWithHttpInfo
     *
     * Read transaction details
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $transaction_id This identification is given by the attribute transactionId of the corresponding entry of a transaction list. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\InlineResponse2001|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransactionDetailsWithHttpInfo($associative_array)
    {
        $request = $this->getTransactionDetailsRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\InlineResponse2001' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\InlineResponse2001', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\BankIO\Sdk\Model\Error406NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error406NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BankIO\Sdk\Model\Error429NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error429NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\InlineResponse2001';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTransactionDetailsAsync
     *
     * Read transaction details
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $transaction_id This identification is given by the attribute transactionId of the corresponding entry of a transaction list. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getTransactionDetailsAsync($associative_array)
    {
        return $this->getTransactionDetailsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransactionDetailsAsyncWithHttpInfo
     *
     * Read transaction details
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $transaction_id This identification is given by the attribute transactionId of the corresponding entry of a transaction list. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getTransactionDetailsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\InlineResponse2001';
        $request = $this->getTransactionDetailsRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransactionDetails'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $transaction_id This identification is given by the attribute transactionId of the corresponding entry of a transaction list. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getTransactionDetailsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $account_id = array_key_exists('account_id', $associative_array) ? $associative_array['account_id'] : null;
        $transaction_id = array_key_exists('transaction_id', $associative_array) ? $associative_array['transaction_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $consent_id = array_key_exists('consent_id', $associative_array) ? $associative_array['consent_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getTransactionDetails'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getTransactionDetails'
            );
        }
        // verify the required parameter 'transaction_id' is set
        if ($transaction_id === null || (is_array($transaction_id) && count($transaction_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transaction_id when calling getTransactionDetails'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getTransactionDetails'
            );
        }
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getTransactionDetails'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.getTransactionDetails, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/accounts/{account-id}/transactions/{transactionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($consent_id !== null) {
            $headerParams['Consent-ID'] = ObjectSerializer::toHeaderValue($consent_id);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'account-id' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }
        // path params
        if ($transaction_id !== null) {
            $resourcePath = str_replace(
                '{' . 'transactionId' . '}',
                ObjectSerializer::toPathValue($transaction_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransactionList
     *
     * Read transaction list of an account
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $booking_status Permitted codes are    * \&quot;information\&quot;,   * \&quot;booked\&quot;,   * \&quot;pending\&quot;, and    * \&quot;both\&quot; \&quot;booked\&quot; shall be supported by the ASPSP. To support the \&quot;pending\&quot; and \&quot;both\&quot; feature is optional for the ASPSP,  Error code if not supported in the online banking frontend (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  \DateTime $date_from Conditional: Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required and if bookingStatus does not equal \&quot;information.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  \DateTime $date_to End date (inclusive the data dateTo) of the transaction list, default is \&quot;now\&quot; if not given.   Might be ignored if a delta function is used.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  string $entry_reference_from This data attribute is indicating that the AISP is in favour to get all transactions after  the transaction with identification entryReferenceFrom alternatively to the above defined period.  This is a implementation of a delta access.  If this data element is contained, the entries \&quot;dateFrom\&quot; and \&quot;dateTo\&quot; might be ignored by the ASPSP  if a delta report is supported.  Optional if supported by API provider. (optional)
     * @param  bool $delta_list This data attribute is indicating that the AISP is in favour to get all transactions after the last report access for this PSU on the addressed account. This is another implementation of a delta access-report. This delta indicator might be rejected by the ASPSP if this function is not supported. Optional if supported by API provider (optional)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\TransactionsResponse200Json|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS
     */
    public function getTransactionList($associative_array)
    {
        list($response) = $this->getTransactionListWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getTransactionListWithHttpInfo
     *
     * Read transaction list of an account
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $booking_status Permitted codes are    * \&quot;information\&quot;,   * \&quot;booked\&quot;,   * \&quot;pending\&quot;, and    * \&quot;both\&quot; \&quot;booked\&quot; shall be supported by the ASPSP. To support the \&quot;pending\&quot; and \&quot;both\&quot; feature is optional for the ASPSP,  Error code if not supported in the online banking frontend (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  \DateTime $date_from Conditional: Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required and if bookingStatus does not equal \&quot;information.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  \DateTime $date_to End date (inclusive the data dateTo) of the transaction list, default is \&quot;now\&quot; if not given.   Might be ignored if a delta function is used.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  string $entry_reference_from This data attribute is indicating that the AISP is in favour to get all transactions after  the transaction with identification entryReferenceFrom alternatively to the above defined period.  This is a implementation of a delta access.  If this data element is contained, the entries \&quot;dateFrom\&quot; and \&quot;dateTo\&quot; might be ignored by the ASPSP  if a delta report is supported.  Optional if supported by API provider. (optional)
     * @param  bool $delta_list This data attribute is indicating that the AISP is in favour to get all transactions after the last report access for this PSU on the addressed account. This is another implementation of a delta access-report. This delta indicator might be rejected by the ASPSP if this function is not supported. Optional if supported by API provider (optional)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\TransactionsResponse200Json|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransactionListWithHttpInfo($associative_array)
    {
        $request = $this->getTransactionListRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\TransactionsResponse200Json' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\TransactionsResponse200Json', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\BankIO\Sdk\Model\Error406NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error406NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BankIO\Sdk\Model\Error429NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error429NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\TransactionsResponse200Json';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\TransactionsResponse200Json',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTransactionListAsync
     *
     * Read transaction list of an account
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $booking_status Permitted codes are    * \&quot;information\&quot;,   * \&quot;booked\&quot;,   * \&quot;pending\&quot;, and    * \&quot;both\&quot; \&quot;booked\&quot; shall be supported by the ASPSP. To support the \&quot;pending\&quot; and \&quot;both\&quot; feature is optional for the ASPSP,  Error code if not supported in the online banking frontend (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  \DateTime $date_from Conditional: Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required and if bookingStatus does not equal \&quot;information.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  \DateTime $date_to End date (inclusive the data dateTo) of the transaction list, default is \&quot;now\&quot; if not given.   Might be ignored if a delta function is used.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  string $entry_reference_from This data attribute is indicating that the AISP is in favour to get all transactions after  the transaction with identification entryReferenceFrom alternatively to the above defined period.  This is a implementation of a delta access.  If this data element is contained, the entries \&quot;dateFrom\&quot; and \&quot;dateTo\&quot; might be ignored by the ASPSP  if a delta report is supported.  Optional if supported by API provider. (optional)
     * @param  bool $delta_list This data attribute is indicating that the AISP is in favour to get all transactions after the last report access for this PSU on the addressed account. This is another implementation of a delta access-report. This delta indicator might be rejected by the ASPSP if this function is not supported. Optional if supported by API provider (optional)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getTransactionListAsync($associative_array)
    {
        return $this->getTransactionListAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransactionListAsyncWithHttpInfo
     *
     * Read transaction list of an account
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $booking_status Permitted codes are    * \&quot;information\&quot;,   * \&quot;booked\&quot;,   * \&quot;pending\&quot;, and    * \&quot;both\&quot; \&quot;booked\&quot; shall be supported by the ASPSP. To support the \&quot;pending\&quot; and \&quot;both\&quot; feature is optional for the ASPSP,  Error code if not supported in the online banking frontend (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  \DateTime $date_from Conditional: Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required and if bookingStatus does not equal \&quot;information.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  \DateTime $date_to End date (inclusive the data dateTo) of the transaction list, default is \&quot;now\&quot; if not given.   Might be ignored if a delta function is used.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  string $entry_reference_from This data attribute is indicating that the AISP is in favour to get all transactions after  the transaction with identification entryReferenceFrom alternatively to the above defined period.  This is a implementation of a delta access.  If this data element is contained, the entries \&quot;dateFrom\&quot; and \&quot;dateTo\&quot; might be ignored by the ASPSP  if a delta report is supported.  Optional if supported by API provider. (optional)
     * @param  bool $delta_list This data attribute is indicating that the AISP is in favour to get all transactions after the last report access for this PSU on the addressed account. This is another implementation of a delta access-report. This delta indicator might be rejected by the ASPSP if this function is not supported. Optional if supported by API provider (optional)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getTransactionListAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\TransactionsResponse200Json';
        $request = $this->getTransactionListRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransactionList'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $booking_status Permitted codes are    * \&quot;information\&quot;,   * \&quot;booked\&quot;,   * \&quot;pending\&quot;, and    * \&quot;both\&quot; \&quot;booked\&quot; shall be supported by the ASPSP. To support the \&quot;pending\&quot; and \&quot;both\&quot; feature is optional for the ASPSP,  Error code if not supported in the online banking frontend (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  \DateTime $date_from Conditional: Starting date (inclusive the date dateFrom) of the transaction list, mandated if no delta access is required and if bookingStatus does not equal \&quot;information.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  \DateTime $date_to End date (inclusive the data dateTo) of the transaction list, default is \&quot;now\&quot; if not given.   Might be ignored if a delta function is used.  For booked transactions, the relevant date is the booking date.   For pending transactions, the relevant date is the entry date, which may not be transparent  neither in this API nor other channels of the ASPSP. (optional)
     * @param  string $entry_reference_from This data attribute is indicating that the AISP is in favour to get all transactions after  the transaction with identification entryReferenceFrom alternatively to the above defined period.  This is a implementation of a delta access.  If this data element is contained, the entries \&quot;dateFrom\&quot; and \&quot;dateTo\&quot; might be ignored by the ASPSP  if a delta report is supported.  Optional if supported by API provider. (optional)
     * @param  bool $delta_list This data attribute is indicating that the AISP is in favour to get all transactions after the last report access for this PSU on the addressed account. This is another implementation of a delta access-report. This delta indicator might be rejected by the ASPSP if this function is not supported. Optional if supported by API provider (optional)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getTransactionListRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $account_id = array_key_exists('account_id', $associative_array) ? $associative_array['account_id'] : null;
        $booking_status = array_key_exists('booking_status', $associative_array) ? $associative_array['booking_status'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $consent_id = array_key_exists('consent_id', $associative_array) ? $associative_array['consent_id'] : null;
        $date_from = array_key_exists('date_from', $associative_array) ? $associative_array['date_from'] : null;
        $date_to = array_key_exists('date_to', $associative_array) ? $associative_array['date_to'] : null;
        $entry_reference_from = array_key_exists('entry_reference_from', $associative_array) ? $associative_array['entry_reference_from'] : null;
        $delta_list = array_key_exists('delta_list', $associative_array) ? $associative_array['delta_list'] : null;
        $with_balance = array_key_exists('with_balance', $associative_array) ? $associative_array['with_balance'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getTransactionList'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getTransactionList'
            );
        }
        // verify the required parameter 'booking_status' is set
        if ($booking_status === null || (is_array($booking_status) && count($booking_status) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $booking_status when calling getTransactionList'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getTransactionList'
            );
        }
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getTransactionList'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.getTransactionList, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/accounts/{account-id}/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date_from !== null) {
            if('form' === 'form' && is_array($date_from)) {
                foreach($date_from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dateFrom'] = $date_from;
            }
        }
        // query params
        if ($date_to !== null) {
            if('form' === 'form' && is_array($date_to)) {
                foreach($date_to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dateTo'] = $date_to;
            }
        }
        // query params
        if ($entry_reference_from !== null) {
            if('form' === 'form' && is_array($entry_reference_from)) {
                foreach($entry_reference_from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['entryReferenceFrom'] = $entry_reference_from;
            }
        }
        // query params
        if ($booking_status !== null) {
            if('form' === 'form' && is_array($booking_status)) {
                foreach($booking_status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['bookingStatus'] = $booking_status;
            }
        }
        // query params
        if ($delta_list !== null) {
            if('form' === 'form' && is_array($delta_list)) {
                foreach($delta_list as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['deltaList'] = $delta_list;
            }
        }
        // query params
        if ($with_balance !== null) {
            if('form' === 'form' && is_array($with_balance)) {
                foreach($with_balance as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withBalance'] = $with_balance;
            }
        }

        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($consent_id !== null) {
            $headerParams['Consent-ID'] = ObjectSerializer::toHeaderValue($consent_id);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'account-id' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml', 'text/plain', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml', 'text/plain', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readAccountDetails
     *
     * Read account details
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\InlineResponse200|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS
     */
    public function readAccountDetails($associative_array)
    {
        list($response) = $this->readAccountDetailsWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation readAccountDetailsWithHttpInfo
     *
     * Read account details
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\InlineResponse200|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function readAccountDetailsWithHttpInfo($associative_array)
    {
        $request = $this->readAccountDetailsRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\InlineResponse200' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\InlineResponse200', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\BankIO\Sdk\Model\Error406NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error406NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BankIO\Sdk\Model\Error429NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error429NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\InlineResponse200';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\InlineResponse200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readAccountDetailsAsync
     *
     * Read account details
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function readAccountDetailsAsync($associative_array)
    {
        return $this->readAccountDetailsAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readAccountDetailsAsyncWithHttpInfo
     *
     * Read account details
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function readAccountDetailsAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\InlineResponse200';
        $request = $this->readAccountDetailsRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readAccountDetails'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  bool $with_balance If contained, this function reads the list of accessible payment accounts including the booking balance,  if granted by the PSU in the related consent and available by the ASPSP.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function readAccountDetailsRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $account_id = array_key_exists('account_id', $associative_array) ? $associative_array['account_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $consent_id = array_key_exists('consent_id', $associative_array) ? $associative_array['consent_id'] : null;
        $with_balance = array_key_exists('with_balance', $associative_array) ? $associative_array['with_balance'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling readAccountDetails'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling readAccountDetails'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling readAccountDetails'
            );
        }
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling readAccountDetails'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.readAccountDetails, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/accounts/{account-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($with_balance !== null) {
            if('form' === 'form' && is_array($with_balance)) {
                foreach($with_balance as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withBalance'] = $with_balance;
            }
        }

        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($consent_id !== null) {
            $headerParams['Consent-ID'] = ObjectSerializer::toHeaderValue($consent_id);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'account-id' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation readCardAccount
     *
     * Read details about a card account
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\InlineResponse2002|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS
     */
    public function readCardAccount($associative_array)
    {
        list($response) = $this->readCardAccountWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation readCardAccountWithHttpInfo
     *
     * Read details about a card account
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\InlineResponse2002|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function readCardAccountWithHttpInfo($associative_array)
    {
        $request = $this->readCardAccountRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\InlineResponse2002' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\InlineResponse2002', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\BankIO\Sdk\Model\Error406NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error406NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BankIO\Sdk\Model\Error429NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error429NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\InlineResponse2002';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation readCardAccountAsync
     *
     * Read details about a card account
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function readCardAccountAsync($associative_array)
    {
        return $this->readCardAccountAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation readCardAccountAsyncWithHttpInfo
     *
     * Read details about a card account
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function readCardAccountAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\InlineResponse2002';
        $request = $this->readCardAccountRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'readCardAccount'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $account_id This identification is denoting the addressed account.  The account-id is retrieved by using a \&quot;Read account list\&quot; call. The account-id is the \&quot;id\&quot; attribute of the account structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $consent_id This then contains the consentId of the related AIS consent, which was performed prior to this payment initiation. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function readCardAccountRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $account_id = array_key_exists('account_id', $associative_array) ? $associative_array['account_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $consent_id = array_key_exists('consent_id', $associative_array) ? $associative_array['consent_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling readCardAccount'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling readCardAccount'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling readCardAccount'
            );
        }
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling readCardAccount'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.readCardAccount, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/card-accounts/{account-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($consent_id !== null) {
            $headerParams['Consent-ID'] = ObjectSerializer::toHeaderValue($consent_id);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'account-id' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startConsentAuthorisation
     *
     * Start the authorisation process for a consent
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\StartScaprocessResponse|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS
     */
    public function startConsentAuthorisation($associative_array)
    {
        list($response) = $this->startConsentAuthorisationWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation startConsentAuthorisationWithHttpInfo
     *
     * Start the authorisation process for a consent
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\StartScaprocessResponse|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function startConsentAuthorisationWithHttpInfo($associative_array)
    {
        $request = $this->startConsentAuthorisationRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 201:
                    if ('\BankIO\Sdk\Model\StartScaprocessResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\StartScaprocessResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\BankIO\Sdk\Model\Error406NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error406NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BankIO\Sdk\Model\Error429NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error429NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\StartScaprocessResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\StartScaprocessResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation startConsentAuthorisationAsync
     *
     * Start the authorisation process for a consent
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function startConsentAuthorisationAsync($associative_array)
    {
        return $this->startConsentAuthorisationAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startConsentAuthorisationAsyncWithHttpInfo
     *
     * Start the authorisation process for a consent
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function startConsentAuthorisationAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\StartScaprocessResponse';
        $request = $this->startConsentAuthorisationRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startConsentAuthorisation'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function startConsentAuthorisationRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $consent_id = array_key_exists('consent_id', $associative_array) ? $associative_array['consent_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_id = array_key_exists('psu_id', $associative_array) ? $associative_array['psu_id'] : null;
        $psu_id_type = array_key_exists('psu_id_type', $associative_array) ? $associative_array['psu_id_type'] : null;
        $psu_corporate_id = array_key_exists('psu_corporate_id', $associative_array) ? $associative_array['psu_corporate_id'] : null;
        $psu_corporate_id_type = array_key_exists('psu_corporate_id_type', $associative_array) ? $associative_array['psu_corporate_id_type'] : null;
        $tpp_redirect_preferred = array_key_exists('tpp_redirect_preferred', $associative_array) ? $associative_array['tpp_redirect_preferred'] : null;
        $tpp_redirect_uri = array_key_exists('tpp_redirect_uri', $associative_array) ? $associative_array['tpp_redirect_uri'] : null;
        $tpp_nok_redirect_uri = array_key_exists('tpp_nok_redirect_uri', $associative_array) ? $associative_array['tpp_nok_redirect_uri'] : null;
        $tpp_notification_uri = array_key_exists('tpp_notification_uri', $associative_array) ? $associative_array['tpp_notification_uri'] : null;
        $tpp_notification_content_preferred = array_key_exists('tpp_notification_content_preferred', $associative_array) ? $associative_array['tpp_notification_content_preferred'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;
        $unknown_base_type = array_key_exists('unknown_base_type', $associative_array) ? $associative_array['unknown_base_type'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling startConsentAuthorisation'
            );
        }
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling startConsentAuthorisation'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling startConsentAuthorisation'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.startConsentAuthorisation, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/consents/{consentId}/authorisations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_id !== null) {
            $headerParams['PSU-ID'] = ObjectSerializer::toHeaderValue($psu_id);
        }
        // header params
        if ($psu_id_type !== null) {
            $headerParams['PSU-ID-Type'] = ObjectSerializer::toHeaderValue($psu_id_type);
        }
        // header params
        if ($psu_corporate_id !== null) {
            $headerParams['PSU-Corporate-ID'] = ObjectSerializer::toHeaderValue($psu_corporate_id);
        }
        // header params
        if ($psu_corporate_id_type !== null) {
            $headerParams['PSU-Corporate-ID-Type'] = ObjectSerializer::toHeaderValue($psu_corporate_id_type);
        }
        // header params
        if ($tpp_redirect_preferred !== null) {
            $headerParams['TPP-Redirect-Preferred'] = ObjectSerializer::toHeaderValue($tpp_redirect_preferred);
        }
        // header params
        if ($tpp_redirect_uri !== null) {
            $headerParams['TPP-Redirect-URI'] = ObjectSerializer::toHeaderValue($tpp_redirect_uri);
        }
        // header params
        if ($tpp_nok_redirect_uri !== null) {
            $headerParams['TPP-Nok-Redirect-URI'] = ObjectSerializer::toHeaderValue($tpp_nok_redirect_uri);
        }
        // header params
        if ($tpp_notification_uri !== null) {
            $headerParams['TPP-Notification-URI'] = ObjectSerializer::toHeaderValue($tpp_notification_uri);
        }
        // header params
        if ($tpp_notification_content_preferred !== null) {
            $headerParams['TPP-Notification-Content-Preferred'] = ObjectSerializer::toHeaderValue($tpp_notification_content_preferred);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateConsentsPsuData
     *
     * Update PSU Data for consents
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS
     */
    public function updateConsentsPsuData($associative_array)
    {
        list($response) = $this->updateConsentsPsuDataWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation updateConsentsPsuDataWithHttpInfo
     *
     * Update PSU Data for consents
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse|\BankIO\Sdk\Model\Error400NGAIS|\BankIO\Sdk\Model\Error401NGAIS|\BankIO\Sdk\Model\Error403NGAIS|\BankIO\Sdk\Model\Error404NGAIS|\BankIO\Sdk\Model\Error405NGAIS|\BankIO\Sdk\Model\Error406NGAIS|\BankIO\Sdk\Model\Error409NGAIS|\BankIO\Sdk\Model\Error429NGAIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateConsentsPsuDataWithHttpInfo($associative_array)
    {
        $request = $this->updateConsentsPsuDataRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (HttpException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (NetworkException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 406:
                    if ('\BankIO\Sdk\Model\Error406NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error406NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\BankIO\Sdk\Model\Error429NGAIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error429NGAIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 406:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error406NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error429NGAIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateConsentsPsuDataAsync
     *
     * Update PSU Data for consents
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function updateConsentsPsuDataAsync($associative_array)
    {
        return $this->updateConsentsPsuDataAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateConsentsPsuDataAsyncWithHttpInfo
     *
     * Update PSU Data for consents
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function updateConsentsPsuDataAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse';
        $request = $this->updateConsentsPsuDataRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateConsentsPsuData'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $consent_id ID of the corresponding consent object as returned by an account information consent request. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding HTTP request  IP Address field between PSU and TPP.  It shall be contained if and only if this request was actively initiated by the PSU. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function updateConsentsPsuDataRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $consent_id = array_key_exists('consent_id', $associative_array) ? $associative_array['consent_id'] : null;
        $authorisation_id = array_key_exists('authorisation_id', $associative_array) ? $associative_array['authorisation_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_id = array_key_exists('psu_id', $associative_array) ? $associative_array['psu_id'] : null;
        $psu_id_type = array_key_exists('psu_id_type', $associative_array) ? $associative_array['psu_id_type'] : null;
        $psu_corporate_id = array_key_exists('psu_corporate_id', $associative_array) ? $associative_array['psu_corporate_id'] : null;
        $psu_corporate_id_type = array_key_exists('psu_corporate_id_type', $associative_array) ? $associative_array['psu_corporate_id_type'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;
        $unknown_base_type = array_key_exists('unknown_base_type', $associative_array) ? $associative_array['unknown_base_type'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling updateConsentsPsuData'
            );
        }
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling updateConsentsPsuData'
            );
        }
        // verify the required parameter 'authorisation_id' is set
        if ($authorisation_id === null || (is_array($authorisation_id) && count($authorisation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorisation_id when calling updateConsentsPsuData'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling updateConsentsPsuData'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling AccountInformationServiceAISApi.updateConsentsPsuData, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/consents/{consentId}/authorisations/{authorisationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_id !== null) {
            $headerParams['PSU-ID'] = ObjectSerializer::toHeaderValue($psu_id);
        }
        // header params
        if ($psu_id_type !== null) {
            $headerParams['PSU-ID-Type'] = ObjectSerializer::toHeaderValue($psu_id_type);
        }
        // header params
        if ($psu_corporate_id !== null) {
            $headerParams['PSU-Corporate-ID'] = ObjectSerializer::toHeaderValue($psu_corporate_id);
        }
        // header params
        if ($psu_corporate_id_type !== null) {
            $headerParams['PSU-Corporate-ID-Type'] = ObjectSerializer::toHeaderValue($psu_corporate_id_type);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }
        // path params
        if ($authorisation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'authorisationId' . '}',
                ObjectSerializer::toPathValue($authorisation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
        }

        return $options;
    }

    /**
    * Safely opens a PHP stream resource using a filename.
    *
    * When fopen fails, PHP normally raises a warning. This function adds an
    * error handler that checks for errors and throws an exception instead.
    *
    * @param string $filename File to open
    * @param string $mode     Mode used to open the file
    *
    * @return resource
    *
    * @throws \RuntimeException if the file cannot be opened
    */
    protected function try_fopen(string $filename, string $mode)
    {
        $ex = null;
        set_error_handler(function (int $errno, string $errstr) use ($filename, $mode, &$ex) {
            $ex = new \RuntimeException(sprintf(
                'Unable to open %s using mode %s: %s',
                $filename,
                $mode,
                $errstr
            ));
        });

        /** @var resource $handle */
        $handle = fopen($filename, $mode);
        restore_error_handler();

        if ($ex) {
            /** @var $ex \RuntimeException */
            throw $ex;
        }

        return $handle;
    }
}
