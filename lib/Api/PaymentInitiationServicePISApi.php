<?php
/**
 * PaymentInitiationServicePISApi
 * PHP version 7.2
 *
 * @category Class
 * @package  BankIO\Sdk
 * @author   bankIO
 * @link     https://bankio.co.uk/bankio-link/
 */

/**
 * bankIO NextGenPSD2 XS2A Framework
 *
 * # Summary The **NextGenPSD2** *Framework Version 1.3.6* (with errata) offers a modern, open, harmonised and interoperable set of Application Programming Interfaces (APIs) as the safest and most efficient way to provide data securely. The NextGenPSD2 Framework reduces XS2A complexity and costs, addresses the problem of multiple competing standards  in Europe and, aligned with the goals of the Euro Retail Payments Board, enables European banking customers to benefit from innovative products and services ('Banking as a Service') by granting TPPs safe and secure (authenticated and authorised) access to their bank accounts and financial data.  The possible Approaches are:   * Redirect SCA Approach   * OAuth SCA Approach   * Decoupled SCA Approach   * Embedded SCA Approach without SCA method   * Embedded SCA Approach with only one SCA method available   * Embedded SCA Approach with Selection of a SCA method    Not every message defined in this API definition is necessary for all approaches.    Furthermore this API definition does not differ between methods which are mandatory, conditional, or optional.   Therefore for a particular implementation of a Berlin Group PSD2 compliant API it is only necessary to support    a certain subset of the methods defined in this API definition.    **Please have a look at the implementation guidelines if you are not sure    which message has to be used for the approach you are going to use.**  ## Some General Remarks Related to this version of the OpenAPI Specification: * **This API definition is based on the Implementation Guidelines of the Berlin Group PSD2 API.**    It is not a replacement in any sense.   The main specification is (at the moment) always the Implementation Guidelines of the Berlin Group PSD2 API. * **This API definition contains the REST-API for requests from the PISP to the ASPSP.** * **This API definition contains the messages for all different approaches defined in the Implementation Guidelines.** * According to the OpenAPI-Specification [https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md]        \"If in is \"header\" and the name field is \"Accept\", \"Content-Type\" or \"Authorization\", the parameter definition SHALL be ignored.\"      The element \"Accept\" will not be defined in this file at any place.      The elements \"Content-Type\" and \"Authorization\" are implicitly defined by the OpenApi tags \"content\" and \"security\".    * There are several predefined types which might occur in payment initiation messages,    but are not used in the standard JSON messages in the Implementation Guidelines.   Therefore they are not used in the corresponding messages in this file either.   We added them for the convenience of the user.   If there is a payment product, which needs these fields, one can easily use the predefined types.   But the ASPSP need not to accept them in general.    * **We omit the definition of all standard HTTP header elements (mandatory/optional/conditional)    except they are mentioned in the Implementation Guidelines.**   Therefore the implementer might add these in his own realisation of a PSD2 comlient API in addition to the elements defined in this file.     ## General Remarks on Data Types  The Berlin Group definition of UTF-8 strings in context of the PSD2 API has to support at least the following characters  a b c d e f g h i j k l m n o p q r s t u v w x y z  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z  0 1 2 3 4 5 6 7 8 9  / - ? : ( ) . , ' +  Space
 *
 * The version of the OpenAPI document: 1.3.6_2020-05-28
 * Contact: hello@bankio.co.uk
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace BankIO\Sdk\Api;

use Http\Client\HttpClient;
use Http\Client\HttpAsyncClient;
use Http\Message\MessageFactory;
use Http\Discovery\HttpClientDiscovery;
use Http\Discovery\HttpAsyncClientDiscovery;
use Http\Discovery\MessageFactoryDiscovery;
use Http\Discovery\StreamFactoryDiscovery;
use Http\Client\Exception\RequestException;
use Http\Message\StreamFactory;
use Http\Message\MultipartStream\MultipartStreamBuilder;
use Psr\Http\Message\RequestInterface;
use BankIO\Sdk\ApiException;
use BankIO\Sdk\Configuration;
use BankIO\Sdk\HeaderSelector;
use BankIO\Sdk\ObjectSerializer;

/**
 * PaymentInitiationServicePISApi Class Doc Comment
 *
 * @category Class
 * @package  BankIO\Sdk
 * @author   bankIO
 * @link     https://bankio.co.uk/bankio-link/
 */
class PaymentInitiationServicePISApi
{
    /**
     * @var HttpClient
     */
    protected $client;

    /**
     * @var HttpAsyncClient
     */
    protected $asyncClient;

    /**
     * @var MessageFactory
     */
    protected $messageFactory;

    /**
     * @var StreamFactory
     */
    protected $streamFactory;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param HttpClient $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        HttpClient $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        MessageFactory $messageFactory = null,
        StreamFactory $streamFactory = null,
        $host_index = 0
    ) {
        $this->client = $client ?: HttpClientDiscovery::find();
        // $this->asyncClient = $asyncClient ?: HttpAsyncClientDiscovery::find();
        $this->messageFactory = $messageFactory ?: MessageFactoryDiscovery::find();
        $this->streamFactory = $streamFactory ?: StreamFactoryDiscovery::find();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation cancelPayment
     *
     * Payment cancellation request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  bool $tpp_explicit_authorisation_preferred If it equals \&quot;true\&quot;, the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \&quot;false\&quot; or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return |\BankIO\Sdk\Model\PaymentInitiationCancelResponse202|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPISCANC|\BankIO\Sdk\Model\Error409NGPIS
     */
    public function cancelPayment($associative_array)
    {
        list($response) = $this->cancelPaymentWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation cancelPaymentWithHttpInfo
     *
     * Payment cancellation request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  bool $tpp_explicit_authorisation_preferred If it equals \&quot;true\&quot;, the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \&quot;false\&quot; or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of |\BankIO\Sdk\Model\PaymentInitiationCancelResponse202|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPISCANC|\BankIO\Sdk\Model\Error409NGPIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelPaymentWithHttpInfo($associative_array)
    {
        $request = $this->cancelPaymentRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 202:
                    if ('\BankIO\Sdk\Model\PaymentInitiationCancelResponse202' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\PaymentInitiationCancelResponse202', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGPISCANC' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGPISCANC', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\PaymentInitiationCancelResponse202';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\PaymentInitiationCancelResponse202',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGPISCANC',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cancelPaymentAsync
     *
     * Payment cancellation request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  bool $tpp_explicit_authorisation_preferred If it equals \&quot;true\&quot;, the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \&quot;false\&quot; or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function cancelPaymentAsync($associative_array)
    {
        return $this->cancelPaymentAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelPaymentAsyncWithHttpInfo
     *
     * Payment cancellation request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  bool $tpp_explicit_authorisation_preferred If it equals \&quot;true\&quot;, the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \&quot;false\&quot; or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function cancelPaymentAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\PaymentInitiationCancelResponse202';
        $request = $this->cancelPaymentRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelPayment'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  bool $tpp_explicit_authorisation_preferred If it equals \&quot;true\&quot;, the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \&quot;false\&quot; or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function cancelPaymentRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $payment_service = array_key_exists('payment_service', $associative_array) ? $associative_array['payment_service'] : null;
        $payment_product = array_key_exists('payment_product', $associative_array) ? $associative_array['payment_product'] : null;
        $payment_id = array_key_exists('payment_id', $associative_array) ? $associative_array['payment_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $tpp_redirect_preferred = array_key_exists('tpp_redirect_preferred', $associative_array) ? $associative_array['tpp_redirect_preferred'] : null;
        $tpp_nok_redirect_uri = array_key_exists('tpp_nok_redirect_uri', $associative_array) ? $associative_array['tpp_nok_redirect_uri'] : null;
        $tpp_redirect_uri = array_key_exists('tpp_redirect_uri', $associative_array) ? $associative_array['tpp_redirect_uri'] : null;
        $tpp_explicit_authorisation_preferred = array_key_exists('tpp_explicit_authorisation_preferred', $associative_array) ? $associative_array['tpp_explicit_authorisation_preferred'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling cancelPayment'
            );
        }
        // verify the required parameter 'payment_service' is set
        if ($payment_service === null || (is_array($payment_service) && count($payment_service) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_service when calling cancelPayment'
            );
        }
        // verify the required parameter 'payment_product' is set
        if ($payment_product === null || (is_array($payment_product) && count($payment_product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_product when calling cancelPayment'
            );
        }
        // verify the required parameter 'payment_id' is set
        if ($payment_id === null || (is_array($payment_id) && count($payment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_id when calling cancelPayment'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling cancelPayment'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling PaymentInitiationServicePISApi.cancelPayment, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/{payment-service}/{payment-product}/{paymentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($tpp_redirect_preferred !== null) {
            $headerParams['TPP-Redirect-Preferred'] = ObjectSerializer::toHeaderValue($tpp_redirect_preferred);
        }
        // header params
        if ($tpp_nok_redirect_uri !== null) {
            $headerParams['TPP-Nok-Redirect-URI'] = ObjectSerializer::toHeaderValue($tpp_nok_redirect_uri);
        }
        // header params
        if ($tpp_redirect_uri !== null) {
            $headerParams['TPP-Redirect-URI'] = ObjectSerializer::toHeaderValue($tpp_redirect_uri);
        }
        // header params
        if ($tpp_explicit_authorisation_preferred !== null) {
            $headerParams['TPP-Explicit-Authorisation-Preferred'] = ObjectSerializer::toHeaderValue($tpp_explicit_authorisation_preferred);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($payment_service !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-service' . '}',
                ObjectSerializer::toPathValue($payment_service),
                $resourcePath
            );
        }
        // path params
        if ($payment_product !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-product' . '}',
                ObjectSerializer::toPathValue($payment_product),
                $resourcePath
            );
        }
        // path params
        if ($payment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentId' . '}',
                ObjectSerializer::toPathValue($payment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaymentCancellationScaStatus
     *
     * Read the SCA status of the payment cancellation's authorisation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\ScaStatusResponse|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS
     */
    public function getPaymentCancellationScaStatus($associative_array)
    {
        list($response) = $this->getPaymentCancellationScaStatusWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getPaymentCancellationScaStatusWithHttpInfo
     *
     * Read the SCA status of the payment cancellation's authorisation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\ScaStatusResponse|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentCancellationScaStatusWithHttpInfo($associative_array)
    {
        $request = $this->getPaymentCancellationScaStatusRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\ScaStatusResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\ScaStatusResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\ScaStatusResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\ScaStatusResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentCancellationScaStatusAsync
     *
     * Read the SCA status of the payment cancellation's authorisation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getPaymentCancellationScaStatusAsync($associative_array)
    {
        return $this->getPaymentCancellationScaStatusAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentCancellationScaStatusAsyncWithHttpInfo
     *
     * Read the SCA status of the payment cancellation's authorisation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getPaymentCancellationScaStatusAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\ScaStatusResponse';
        $request = $this->getPaymentCancellationScaStatusRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentCancellationScaStatus'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getPaymentCancellationScaStatusRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $payment_service = array_key_exists('payment_service', $associative_array) ? $associative_array['payment_service'] : null;
        $payment_product = array_key_exists('payment_product', $associative_array) ? $associative_array['payment_product'] : null;
        $payment_id = array_key_exists('payment_id', $associative_array) ? $associative_array['payment_id'] : null;
        $authorisation_id = array_key_exists('authorisation_id', $associative_array) ? $associative_array['authorisation_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getPaymentCancellationScaStatus'
            );
        }
        // verify the required parameter 'payment_service' is set
        if ($payment_service === null || (is_array($payment_service) && count($payment_service) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_service when calling getPaymentCancellationScaStatus'
            );
        }
        // verify the required parameter 'payment_product' is set
        if ($payment_product === null || (is_array($payment_product) && count($payment_product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_product when calling getPaymentCancellationScaStatus'
            );
        }
        // verify the required parameter 'payment_id' is set
        if ($payment_id === null || (is_array($payment_id) && count($payment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_id when calling getPaymentCancellationScaStatus'
            );
        }
        // verify the required parameter 'authorisation_id' is set
        if ($authorisation_id === null || (is_array($authorisation_id) && count($authorisation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorisation_id when calling getPaymentCancellationScaStatus'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getPaymentCancellationScaStatus'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling PaymentInitiationServicePISApi.getPaymentCancellationScaStatus, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/{payment-service}/{payment-product}/{paymentId}/cancellation-authorisations/{authorisationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($payment_service !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-service' . '}',
                ObjectSerializer::toPathValue($payment_service),
                $resourcePath
            );
        }
        // path params
        if ($payment_product !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-product' . '}',
                ObjectSerializer::toPathValue($payment_product),
                $resourcePath
            );
        }
        // path params
        if ($payment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentId' . '}',
                ObjectSerializer::toPathValue($payment_id),
                $resourcePath
            );
        }
        // path params
        if ($authorisation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'authorisationId' . '}',
                ObjectSerializer::toPathValue($authorisation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaymentInformation
     *
     * Get payment information
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return OneOfPaymentInitiationWithStatusResponsePeriodicPaymentInitiationWithStatusResponseBulkPaymentInitiationWithStatusResponse|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS
     */
    public function getPaymentInformation($associative_array)
    {
        list($response) = $this->getPaymentInformationWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getPaymentInformationWithHttpInfo
     *
     * Get payment information
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of OneOfPaymentInitiationWithStatusResponsePeriodicPaymentInitiationWithStatusResponseBulkPaymentInitiationWithStatusResponse|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentInformationWithHttpInfo($associative_array)
    {
        $request = $this->getPaymentInformationRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('OneOfPaymentInitiationWithStatusResponsePeriodicPaymentInitiationWithStatusResponseBulkPaymentInitiationWithStatusResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'OneOfPaymentInitiationWithStatusResponsePeriodicPaymentInitiationWithStatusResponseBulkPaymentInitiationWithStatusResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'OneOfPaymentInitiationWithStatusResponsePeriodicPaymentInitiationWithStatusResponseBulkPaymentInitiationWithStatusResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'OneOfPaymentInitiationWithStatusResponsePeriodicPaymentInitiationWithStatusResponseBulkPaymentInitiationWithStatusResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentInformationAsync
     *
     * Get payment information
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getPaymentInformationAsync($associative_array)
    {
        return $this->getPaymentInformationAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentInformationAsyncWithHttpInfo
     *
     * Get payment information
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getPaymentInformationAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'OneOfPaymentInitiationWithStatusResponsePeriodicPaymentInitiationWithStatusResponseBulkPaymentInitiationWithStatusResponse';
        $request = $this->getPaymentInformationRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentInformation'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getPaymentInformationRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $payment_service = array_key_exists('payment_service', $associative_array) ? $associative_array['payment_service'] : null;
        $payment_product = array_key_exists('payment_product', $associative_array) ? $associative_array['payment_product'] : null;
        $payment_id = array_key_exists('payment_id', $associative_array) ? $associative_array['payment_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getPaymentInformation'
            );
        }
        // verify the required parameter 'payment_service' is set
        if ($payment_service === null || (is_array($payment_service) && count($payment_service) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_service when calling getPaymentInformation'
            );
        }
        // verify the required parameter 'payment_product' is set
        if ($payment_product === null || (is_array($payment_product) && count($payment_product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_product when calling getPaymentInformation'
            );
        }
        // verify the required parameter 'payment_id' is set
        if ($payment_id === null || (is_array($payment_id) && count($payment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_id when calling getPaymentInformation'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getPaymentInformation'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling PaymentInitiationServicePISApi.getPaymentInformation, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/{payment-service}/{payment-product}/{paymentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($payment_service !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-service' . '}',
                ObjectSerializer::toPathValue($payment_service),
                $resourcePath
            );
        }
        // path params
        if ($payment_product !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-product' . '}',
                ObjectSerializer::toPathValue($payment_product),
                $resourcePath
            );
        }
        // path params
        if ($payment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentId' . '}',
                ObjectSerializer::toPathValue($payment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml', 'multipart/form-data', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml', 'multipart/form-data', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaymentInitiationAuthorisation
     *
     * Get payment initiation authorisation sub-resources request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\Authorisations|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS
     */
    public function getPaymentInitiationAuthorisation($associative_array)
    {
        list($response) = $this->getPaymentInitiationAuthorisationWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getPaymentInitiationAuthorisationWithHttpInfo
     *
     * Get payment initiation authorisation sub-resources request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\Authorisations|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentInitiationAuthorisationWithHttpInfo($associative_array)
    {
        $request = $this->getPaymentInitiationAuthorisationRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\Authorisations' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Authorisations', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\Authorisations';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Authorisations',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentInitiationAuthorisationAsync
     *
     * Get payment initiation authorisation sub-resources request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getPaymentInitiationAuthorisationAsync($associative_array)
    {
        return $this->getPaymentInitiationAuthorisationAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentInitiationAuthorisationAsyncWithHttpInfo
     *
     * Get payment initiation authorisation sub-resources request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getPaymentInitiationAuthorisationAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\Authorisations';
        $request = $this->getPaymentInitiationAuthorisationRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentInitiationAuthorisation'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getPaymentInitiationAuthorisationRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $payment_service = array_key_exists('payment_service', $associative_array) ? $associative_array['payment_service'] : null;
        $payment_product = array_key_exists('payment_product', $associative_array) ? $associative_array['payment_product'] : null;
        $payment_id = array_key_exists('payment_id', $associative_array) ? $associative_array['payment_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getPaymentInitiationAuthorisation'
            );
        }
        // verify the required parameter 'payment_service' is set
        if ($payment_service === null || (is_array($payment_service) && count($payment_service) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_service when calling getPaymentInitiationAuthorisation'
            );
        }
        // verify the required parameter 'payment_product' is set
        if ($payment_product === null || (is_array($payment_product) && count($payment_product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_product when calling getPaymentInitiationAuthorisation'
            );
        }
        // verify the required parameter 'payment_id' is set
        if ($payment_id === null || (is_array($payment_id) && count($payment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_id when calling getPaymentInitiationAuthorisation'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getPaymentInitiationAuthorisation'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling PaymentInitiationServicePISApi.getPaymentInitiationAuthorisation, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/{payment-service}/{payment-product}/{paymentId}/authorisations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($payment_service !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-service' . '}',
                ObjectSerializer::toPathValue($payment_service),
                $resourcePath
            );
        }
        // path params
        if ($payment_product !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-product' . '}',
                ObjectSerializer::toPathValue($payment_product),
                $resourcePath
            );
        }
        // path params
        if ($payment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentId' . '}',
                ObjectSerializer::toPathValue($payment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaymentInitiationCancellationAuthorisationInformation
     *
     * Will deliver an array of resource identifications to all generated cancellation authorisation sub-resources
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\Authorisations|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS
     */
    public function getPaymentInitiationCancellationAuthorisationInformation($associative_array)
    {
        list($response) = $this->getPaymentInitiationCancellationAuthorisationInformationWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getPaymentInitiationCancellationAuthorisationInformationWithHttpInfo
     *
     * Will deliver an array of resource identifications to all generated cancellation authorisation sub-resources
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\Authorisations|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentInitiationCancellationAuthorisationInformationWithHttpInfo($associative_array)
    {
        $request = $this->getPaymentInitiationCancellationAuthorisationInformationRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\Authorisations' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Authorisations', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\Authorisations';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Authorisations',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentInitiationCancellationAuthorisationInformationAsync
     *
     * Will deliver an array of resource identifications to all generated cancellation authorisation sub-resources
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getPaymentInitiationCancellationAuthorisationInformationAsync($associative_array)
    {
        return $this->getPaymentInitiationCancellationAuthorisationInformationAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentInitiationCancellationAuthorisationInformationAsyncWithHttpInfo
     *
     * Will deliver an array of resource identifications to all generated cancellation authorisation sub-resources
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getPaymentInitiationCancellationAuthorisationInformationAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\Authorisations';
        $request = $this->getPaymentInitiationCancellationAuthorisationInformationRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentInitiationCancellationAuthorisationInformation'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getPaymentInitiationCancellationAuthorisationInformationRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $payment_service = array_key_exists('payment_service', $associative_array) ? $associative_array['payment_service'] : null;
        $payment_product = array_key_exists('payment_product', $associative_array) ? $associative_array['payment_product'] : null;
        $payment_id = array_key_exists('payment_id', $associative_array) ? $associative_array['payment_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getPaymentInitiationCancellationAuthorisationInformation'
            );
        }
        // verify the required parameter 'payment_service' is set
        if ($payment_service === null || (is_array($payment_service) && count($payment_service) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_service when calling getPaymentInitiationCancellationAuthorisationInformation'
            );
        }
        // verify the required parameter 'payment_product' is set
        if ($payment_product === null || (is_array($payment_product) && count($payment_product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_product when calling getPaymentInitiationCancellationAuthorisationInformation'
            );
        }
        // verify the required parameter 'payment_id' is set
        if ($payment_id === null || (is_array($payment_id) && count($payment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_id when calling getPaymentInitiationCancellationAuthorisationInformation'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getPaymentInitiationCancellationAuthorisationInformation'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling PaymentInitiationServicePISApi.getPaymentInitiationCancellationAuthorisationInformation, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/{payment-service}/{payment-product}/{paymentId}/cancellation-authorisations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($payment_service !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-service' . '}',
                ObjectSerializer::toPathValue($payment_service),
                $resourcePath
            );
        }
        // path params
        if ($payment_product !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-product' . '}',
                ObjectSerializer::toPathValue($payment_product),
                $resourcePath
            );
        }
        // path params
        if ($payment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentId' . '}',
                ObjectSerializer::toPathValue($payment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaymentInitiationScaStatus
     *
     * Read the SCA status of the payment authorisation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\ScaStatusResponse|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS
     */
    public function getPaymentInitiationScaStatus($associative_array)
    {
        list($response) = $this->getPaymentInitiationScaStatusWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getPaymentInitiationScaStatusWithHttpInfo
     *
     * Read the SCA status of the payment authorisation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\ScaStatusResponse|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentInitiationScaStatusWithHttpInfo($associative_array)
    {
        $request = $this->getPaymentInitiationScaStatusRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\ScaStatusResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\ScaStatusResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\ScaStatusResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\ScaStatusResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentInitiationScaStatusAsync
     *
     * Read the SCA status of the payment authorisation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getPaymentInitiationScaStatusAsync($associative_array)
    {
        return $this->getPaymentInitiationScaStatusAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentInitiationScaStatusAsyncWithHttpInfo
     *
     * Read the SCA status of the payment authorisation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getPaymentInitiationScaStatusAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\ScaStatusResponse';
        $request = $this->getPaymentInitiationScaStatusRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentInitiationScaStatus'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getPaymentInitiationScaStatusRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $payment_service = array_key_exists('payment_service', $associative_array) ? $associative_array['payment_service'] : null;
        $payment_product = array_key_exists('payment_product', $associative_array) ? $associative_array['payment_product'] : null;
        $payment_id = array_key_exists('payment_id', $associative_array) ? $associative_array['payment_id'] : null;
        $authorisation_id = array_key_exists('authorisation_id', $associative_array) ? $associative_array['authorisation_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getPaymentInitiationScaStatus'
            );
        }
        // verify the required parameter 'payment_service' is set
        if ($payment_service === null || (is_array($payment_service) && count($payment_service) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_service when calling getPaymentInitiationScaStatus'
            );
        }
        // verify the required parameter 'payment_product' is set
        if ($payment_product === null || (is_array($payment_product) && count($payment_product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_product when calling getPaymentInitiationScaStatus'
            );
        }
        // verify the required parameter 'payment_id' is set
        if ($payment_id === null || (is_array($payment_id) && count($payment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_id when calling getPaymentInitiationScaStatus'
            );
        }
        // verify the required parameter 'authorisation_id' is set
        if ($authorisation_id === null || (is_array($authorisation_id) && count($authorisation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorisation_id when calling getPaymentInitiationScaStatus'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getPaymentInitiationScaStatus'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling PaymentInitiationServicePISApi.getPaymentInitiationScaStatus, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/{payment-service}/{payment-product}/{paymentId}/authorisations/{authorisationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($payment_service !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-service' . '}',
                ObjectSerializer::toPathValue($payment_service),
                $resourcePath
            );
        }
        // path params
        if ($payment_product !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-product' . '}',
                ObjectSerializer::toPathValue($payment_product),
                $resourcePath
            );
        }
        // path params
        if ($payment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentId' . '}',
                ObjectSerializer::toPathValue($payment_id),
                $resourcePath
            );
        }
        // path params
        if ($authorisation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'authorisationId' . '}',
                ObjectSerializer::toPathValue($authorisation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaymentInitiationStatus
     *
     * Payment initiation status request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\PaymentInitiationStatusResponse200Json|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS
     */
    public function getPaymentInitiationStatus($associative_array)
    {
        list($response) = $this->getPaymentInitiationStatusWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation getPaymentInitiationStatusWithHttpInfo
     *
     * Payment initiation status request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\PaymentInitiationStatusResponse200Json|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentInitiationStatusWithHttpInfo($associative_array)
    {
        $request = $this->getPaymentInitiationStatusRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\BankIO\Sdk\Model\PaymentInitiationStatusResponse200Json' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\PaymentInitiationStatusResponse200Json', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\PaymentInitiationStatusResponse200Json';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\PaymentInitiationStatusResponse200Json',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPaymentInitiationStatusAsync
     *
     * Payment initiation status request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getPaymentInitiationStatusAsync($associative_array)
    {
        return $this->getPaymentInitiationStatusAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentInitiationStatusAsyncWithHttpInfo
     *
     * Payment initiation status request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function getPaymentInitiationStatusAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\PaymentInitiationStatusResponse200Json';
        $request = $this->getPaymentInitiationStatusRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentInitiationStatus'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function getPaymentInitiationStatusRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $payment_service = array_key_exists('payment_service', $associative_array) ? $associative_array['payment_service'] : null;
        $payment_product = array_key_exists('payment_product', $associative_array) ? $associative_array['payment_product'] : null;
        $payment_id = array_key_exists('payment_id', $associative_array) ? $associative_array['payment_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling getPaymentInitiationStatus'
            );
        }
        // verify the required parameter 'payment_service' is set
        if ($payment_service === null || (is_array($payment_service) && count($payment_service) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_service when calling getPaymentInitiationStatus'
            );
        }
        // verify the required parameter 'payment_product' is set
        if ($payment_product === null || (is_array($payment_product) && count($payment_product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_product when calling getPaymentInitiationStatus'
            );
        }
        // verify the required parameter 'payment_id' is set
        if ($payment_id === null || (is_array($payment_id) && count($payment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_id when calling getPaymentInitiationStatus'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling getPaymentInitiationStatus'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling PaymentInitiationServicePISApi.getPaymentInitiationStatus, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/{payment-service}/{payment-product}/{paymentId}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($payment_service !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-service' . '}',
                ObjectSerializer::toPathValue($payment_service),
                $resourcePath
            );
        }
        // path params
        if ($payment_product !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-product' . '}',
                ObjectSerializer::toPathValue($payment_product),
                $resourcePath
            );
        }
        // path params
        if ($payment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentId' . '}',
                ObjectSerializer::toPathValue($payment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml', 'application/problem+json', ],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation initiatePayment
     *
     * Payment initiation request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $tpp_psu_id Client ID of the PSU in the TPP client interface.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. (required)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. If not available, the TPP shall use the IP Address used by the TPP when submitting this request. (required)
     * @param  \BankIO\Sdk\Model\PaymentInitiationBodyJson $payment_initiation_body_json JSON request body for a payment inition request message.  There are the following payment-products supported:   * \&quot;sepa-credit-transfers\&quot; with JSON-Body   * \&quot;instant-sepa-credit-transfers\&quot; with JSON-Body   * \&quot;target-2-payments\&quot; with JSON-Body   * \&quot;cross-border-credit-transfers\&quot; with JSON-Body   * \&quot;pain.001-sepa-credit-transfers\&quot; with XML pain.001.001.03 body for SCT scheme   * \&quot;pain.001-instant-sepa-credit-transfers\&quot; with XML pain.001.001.03 body for SCT INST scheme   * \&quot;pain.001-target-2-payments\&quot; with pain.001 body.      Only country specific schemes are currently available   * \&quot;pain.001-cross-border-credit-transfers\&quot; with pain.001 body.      Only country specific schemes are currently available    There are the following payment-services supported:   * \&quot;payments\&quot;   * \&quot;periodic-payments\&quot;   * \&quot;bulk-paments\&quot;  All optional, conditional and predefined but not yet used fields are defined. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  bool $tpp_explicit_authorisation_preferred If it equals \&quot;true\&quot;, the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \&quot;false\&quot; or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket. (optional)
     * @param  bool $tpp_rejection_no_funds_preferred If it equals \&quot;true\&quot; then the TPP prefers a rejection of the payment initiation in case the ASPSP is  providing an integrated confirmation of funds request an the result of this is that not sufficient  funds are available.  If it equals \&quot;false\&quot; then the TPP prefers that the ASPSP is dealing with the payment initiation like  in the ASPSPs online channel, potentially waiting for a certain time period for funds to arrive to initiate the payment.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $tpp_brand_logging_information This header might be used by TPPs to inform the ASPSP about the brand used by the TPP towards the PSU.  This information is meant for logging entries to enhance communication between ASPSP and PSU or ASPSP and TPP.  This header might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\PaymentInitationRequestResponse201|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS
     */
    public function initiatePayment($associative_array)
    {
        list($response) = $this->initiatePaymentWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation initiatePaymentWithHttpInfo
     *
     * Payment initiation request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $tpp_psu_id Client ID of the PSU in the TPP client interface.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. (required)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. If not available, the TPP shall use the IP Address used by the TPP when submitting this request. (required)
     * @param  \BankIO\Sdk\Model\PaymentInitiationBodyJson $payment_initiation_body_json JSON request body for a payment inition request message.  There are the following payment-products supported:   * \&quot;sepa-credit-transfers\&quot; with JSON-Body   * \&quot;instant-sepa-credit-transfers\&quot; with JSON-Body   * \&quot;target-2-payments\&quot; with JSON-Body   * \&quot;cross-border-credit-transfers\&quot; with JSON-Body   * \&quot;pain.001-sepa-credit-transfers\&quot; with XML pain.001.001.03 body for SCT scheme   * \&quot;pain.001-instant-sepa-credit-transfers\&quot; with XML pain.001.001.03 body for SCT INST scheme   * \&quot;pain.001-target-2-payments\&quot; with pain.001 body.      Only country specific schemes are currently available   * \&quot;pain.001-cross-border-credit-transfers\&quot; with pain.001 body.      Only country specific schemes are currently available    There are the following payment-services supported:   * \&quot;payments\&quot;   * \&quot;periodic-payments\&quot;   * \&quot;bulk-paments\&quot;  All optional, conditional and predefined but not yet used fields are defined. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  bool $tpp_explicit_authorisation_preferred If it equals \&quot;true\&quot;, the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \&quot;false\&quot; or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket. (optional)
     * @param  bool $tpp_rejection_no_funds_preferred If it equals \&quot;true\&quot; then the TPP prefers a rejection of the payment initiation in case the ASPSP is  providing an integrated confirmation of funds request an the result of this is that not sufficient  funds are available.  If it equals \&quot;false\&quot; then the TPP prefers that the ASPSP is dealing with the payment initiation like  in the ASPSPs online channel, potentially waiting for a certain time period for funds to arrive to initiate the payment.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $tpp_brand_logging_information This header might be used by TPPs to inform the ASPSP about the brand used by the TPP towards the PSU.  This information is meant for logging entries to enhance communication between ASPSP and PSU or ASPSP and TPP.  This header might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\PaymentInitationRequestResponse201|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function initiatePaymentWithHttpInfo($associative_array)
    {
        $request = $this->initiatePaymentRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 201:
                    if ('\BankIO\Sdk\Model\PaymentInitationRequestResponse201' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\PaymentInitationRequestResponse201', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\PaymentInitationRequestResponse201';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\PaymentInitationRequestResponse201',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation initiatePaymentAsync
     *
     * Payment initiation request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $tpp_psu_id Client ID of the PSU in the TPP client interface.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. (required)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. If not available, the TPP shall use the IP Address used by the TPP when submitting this request. (required)
     * @param  \BankIO\Sdk\Model\PaymentInitiationBodyJson $payment_initiation_body_json JSON request body for a payment inition request message.  There are the following payment-products supported:   * \&quot;sepa-credit-transfers\&quot; with JSON-Body   * \&quot;instant-sepa-credit-transfers\&quot; with JSON-Body   * \&quot;target-2-payments\&quot; with JSON-Body   * \&quot;cross-border-credit-transfers\&quot; with JSON-Body   * \&quot;pain.001-sepa-credit-transfers\&quot; with XML pain.001.001.03 body for SCT scheme   * \&quot;pain.001-instant-sepa-credit-transfers\&quot; with XML pain.001.001.03 body for SCT INST scheme   * \&quot;pain.001-target-2-payments\&quot; with pain.001 body.      Only country specific schemes are currently available   * \&quot;pain.001-cross-border-credit-transfers\&quot; with pain.001 body.      Only country specific schemes are currently available    There are the following payment-services supported:   * \&quot;payments\&quot;   * \&quot;periodic-payments\&quot;   * \&quot;bulk-paments\&quot;  All optional, conditional and predefined but not yet used fields are defined. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  bool $tpp_explicit_authorisation_preferred If it equals \&quot;true\&quot;, the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \&quot;false\&quot; or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket. (optional)
     * @param  bool $tpp_rejection_no_funds_preferred If it equals \&quot;true\&quot; then the TPP prefers a rejection of the payment initiation in case the ASPSP is  providing an integrated confirmation of funds request an the result of this is that not sufficient  funds are available.  If it equals \&quot;false\&quot; then the TPP prefers that the ASPSP is dealing with the payment initiation like  in the ASPSPs online channel, potentially waiting for a certain time period for funds to arrive to initiate the payment.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $tpp_brand_logging_information This header might be used by TPPs to inform the ASPSP about the brand used by the TPP towards the PSU.  This information is meant for logging entries to enhance communication between ASPSP and PSU or ASPSP and TPP.  This header might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function initiatePaymentAsync($associative_array)
    {
        return $this->initiatePaymentAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation initiatePaymentAsyncWithHttpInfo
     *
     * Payment initiation request
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $tpp_psu_id Client ID of the PSU in the TPP client interface.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. (required)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. If not available, the TPP shall use the IP Address used by the TPP when submitting this request. (required)
     * @param  \BankIO\Sdk\Model\PaymentInitiationBodyJson $payment_initiation_body_json JSON request body for a payment inition request message.  There are the following payment-products supported:   * \&quot;sepa-credit-transfers\&quot; with JSON-Body   * \&quot;instant-sepa-credit-transfers\&quot; with JSON-Body   * \&quot;target-2-payments\&quot; with JSON-Body   * \&quot;cross-border-credit-transfers\&quot; with JSON-Body   * \&quot;pain.001-sepa-credit-transfers\&quot; with XML pain.001.001.03 body for SCT scheme   * \&quot;pain.001-instant-sepa-credit-transfers\&quot; with XML pain.001.001.03 body for SCT INST scheme   * \&quot;pain.001-target-2-payments\&quot; with pain.001 body.      Only country specific schemes are currently available   * \&quot;pain.001-cross-border-credit-transfers\&quot; with pain.001 body.      Only country specific schemes are currently available    There are the following payment-services supported:   * \&quot;payments\&quot;   * \&quot;periodic-payments\&quot;   * \&quot;bulk-paments\&quot;  All optional, conditional and predefined but not yet used fields are defined. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  bool $tpp_explicit_authorisation_preferred If it equals \&quot;true\&quot;, the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \&quot;false\&quot; or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket. (optional)
     * @param  bool $tpp_rejection_no_funds_preferred If it equals \&quot;true\&quot; then the TPP prefers a rejection of the payment initiation in case the ASPSP is  providing an integrated confirmation of funds request an the result of this is that not sufficient  funds are available.  If it equals \&quot;false\&quot; then the TPP prefers that the ASPSP is dealing with the payment initiation like  in the ASPSPs online channel, potentially waiting for a certain time period for funds to arrive to initiate the payment.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $tpp_brand_logging_information This header might be used by TPPs to inform the ASPSP about the brand used by the TPP towards the PSU.  This information is meant for logging entries to enhance communication between ASPSP and PSU or ASPSP and TPP.  This header might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function initiatePaymentAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\PaymentInitationRequestResponse201';
        $request = $this->initiatePaymentRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'initiatePayment'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $tpp_psu_id Client ID of the PSU in the TPP client interface.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. (required)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. If not available, the TPP shall use the IP Address used by the TPP when submitting this request. (required)
     * @param  \BankIO\Sdk\Model\PaymentInitiationBodyJson $payment_initiation_body_json JSON request body for a payment inition request message.  There are the following payment-products supported:   * \&quot;sepa-credit-transfers\&quot; with JSON-Body   * \&quot;instant-sepa-credit-transfers\&quot; with JSON-Body   * \&quot;target-2-payments\&quot; with JSON-Body   * \&quot;cross-border-credit-transfers\&quot; with JSON-Body   * \&quot;pain.001-sepa-credit-transfers\&quot; with XML pain.001.001.03 body for SCT scheme   * \&quot;pain.001-instant-sepa-credit-transfers\&quot; with XML pain.001.001.03 body for SCT INST scheme   * \&quot;pain.001-target-2-payments\&quot; with pain.001 body.      Only country specific schemes are currently available   * \&quot;pain.001-cross-border-credit-transfers\&quot; with pain.001 body.      Only country specific schemes are currently available    There are the following payment-services supported:   * \&quot;payments\&quot;   * \&quot;periodic-payments\&quot;   * \&quot;bulk-paments\&quot;  All optional, conditional and predefined but not yet used fields are defined. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  bool $tpp_explicit_authorisation_preferred If it equals \&quot;true\&quot;, the TPP prefers to start the authorisation process separately,  e.g. because of the usage of a signing basket.  This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.  If it equals \&quot;false\&quot; or if the parameter is not used, there is no preference of the TPP.  This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,  without using a signing basket. (optional)
     * @param  bool $tpp_rejection_no_funds_preferred If it equals \&quot;true\&quot; then the TPP prefers a rejection of the payment initiation in case the ASPSP is  providing an integrated confirmation of funds request an the result of this is that not sufficient  funds are available.  If it equals \&quot;false\&quot; then the TPP prefers that the ASPSP is dealing with the payment initiation like  in the ASPSPs online channel, potentially waiting for a certain time period for funds to arrive to initiate the payment.  This parameter might be ignored by the ASPSP. (optional)
     * @param  string $tpp_brand_logging_information This header might be used by TPPs to inform the ASPSP about the brand used by the TPP towards the PSU.  This information is meant for logging entries to enhance communication between ASPSP and PSU or ASPSP and TPP.  This header might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function initiatePaymentRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $payment_service = array_key_exists('payment_service', $associative_array) ? $associative_array['payment_service'] : null;
        $payment_product = array_key_exists('payment_product', $associative_array) ? $associative_array['payment_product'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $tpp_psu_id = array_key_exists('tpp_psu_id', $associative_array) ? $associative_array['tpp_psu_id'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $payment_initiation_body_json = array_key_exists('payment_initiation_body_json', $associative_array) ? $associative_array['payment_initiation_body_json'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_id = array_key_exists('psu_id', $associative_array) ? $associative_array['psu_id'] : null;
        $psu_id_type = array_key_exists('psu_id_type', $associative_array) ? $associative_array['psu_id_type'] : null;
        $psu_corporate_id = array_key_exists('psu_corporate_id', $associative_array) ? $associative_array['psu_corporate_id'] : null;
        $psu_corporate_id_type = array_key_exists('psu_corporate_id_type', $associative_array) ? $associative_array['psu_corporate_id_type'] : null;
        $tpp_redirect_preferred = array_key_exists('tpp_redirect_preferred', $associative_array) ? $associative_array['tpp_redirect_preferred'] : null;
        $tpp_redirect_uri = array_key_exists('tpp_redirect_uri', $associative_array) ? $associative_array['tpp_redirect_uri'] : null;
        $tpp_nok_redirect_uri = array_key_exists('tpp_nok_redirect_uri', $associative_array) ? $associative_array['tpp_nok_redirect_uri'] : null;
        $tpp_explicit_authorisation_preferred = array_key_exists('tpp_explicit_authorisation_preferred', $associative_array) ? $associative_array['tpp_explicit_authorisation_preferred'] : null;
        $tpp_rejection_no_funds_preferred = array_key_exists('tpp_rejection_no_funds_preferred', $associative_array) ? $associative_array['tpp_rejection_no_funds_preferred'] : null;
        $tpp_brand_logging_information = array_key_exists('tpp_brand_logging_information', $associative_array) ? $associative_array['tpp_brand_logging_information'] : null;
        $tpp_notification_uri = array_key_exists('tpp_notification_uri', $associative_array) ? $associative_array['tpp_notification_uri'] : null;
        $tpp_notification_content_preferred = array_key_exists('tpp_notification_content_preferred', $associative_array) ? $associative_array['tpp_notification_content_preferred'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling initiatePayment'
            );
        }
        // verify the required parameter 'payment_service' is set
        if ($payment_service === null || (is_array($payment_service) && count($payment_service) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_service when calling initiatePayment'
            );
        }
        // verify the required parameter 'payment_product' is set
        if ($payment_product === null || (is_array($payment_product) && count($payment_product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_product when calling initiatePayment'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling initiatePayment'
            );
        }
        // verify the required parameter 'tpp_psu_id' is set
        if ($tpp_psu_id === null || (is_array($tpp_psu_id) && count($tpp_psu_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tpp_psu_id when calling initiatePayment'
            );
        }
        // verify the required parameter 'psu_ip_address' is set
        if ($psu_ip_address === null || (is_array($psu_ip_address) && count($psu_ip_address) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $psu_ip_address when calling initiatePayment'
            );
        }
        // verify the required parameter 'payment_initiation_body_json' is set
        if ($payment_initiation_body_json === null || (is_array($payment_initiation_body_json) && count($payment_initiation_body_json) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_initiation_body_json when calling initiatePayment'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling PaymentInitiationServicePISApi.initiatePayment, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/{payment-service}/{payment-product}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($tpp_psu_id !== null) {
            $headerParams['TPP-PSU-ID'] = ObjectSerializer::toHeaderValue($tpp_psu_id);
        }
        // header params
        if ($psu_id !== null) {
            $headerParams['PSU-ID'] = ObjectSerializer::toHeaderValue($psu_id);
        }
        // header params
        if ($psu_id_type !== null) {
            $headerParams['PSU-ID-Type'] = ObjectSerializer::toHeaderValue($psu_id_type);
        }
        // header params
        if ($psu_corporate_id !== null) {
            $headerParams['PSU-Corporate-ID'] = ObjectSerializer::toHeaderValue($psu_corporate_id);
        }
        // header params
        if ($psu_corporate_id_type !== null) {
            $headerParams['PSU-Corporate-ID-Type'] = ObjectSerializer::toHeaderValue($psu_corporate_id_type);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($tpp_redirect_preferred !== null) {
            $headerParams['TPP-Redirect-Preferred'] = ObjectSerializer::toHeaderValue($tpp_redirect_preferred);
        }
        // header params
        if ($tpp_redirect_uri !== null) {
            $headerParams['TPP-Redirect-URI'] = ObjectSerializer::toHeaderValue($tpp_redirect_uri);
        }
        // header params
        if ($tpp_nok_redirect_uri !== null) {
            $headerParams['TPP-Nok-Redirect-URI'] = ObjectSerializer::toHeaderValue($tpp_nok_redirect_uri);
        }
        // header params
        if ($tpp_explicit_authorisation_preferred !== null) {
            $headerParams['TPP-Explicit-Authorisation-Preferred'] = ObjectSerializer::toHeaderValue($tpp_explicit_authorisation_preferred);
        }
        // header params
        if ($tpp_rejection_no_funds_preferred !== null) {
            $headerParams['TPP-Rejection-NoFunds-Preferred'] = ObjectSerializer::toHeaderValue($tpp_rejection_no_funds_preferred);
        }
        // header params
        if ($tpp_brand_logging_information !== null) {
            $headerParams['TPP-Brand-Logging-Information'] = ObjectSerializer::toHeaderValue($tpp_brand_logging_information);
        }
        // header params
        if ($tpp_notification_uri !== null) {
            $headerParams['TPP-Notification-URI'] = ObjectSerializer::toHeaderValue($tpp_notification_uri);
        }
        // header params
        if ($tpp_notification_content_preferred !== null) {
            $headerParams['TPP-Notification-Content-Preferred'] = ObjectSerializer::toHeaderValue($tpp_notification_content_preferred);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($payment_service !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-service' . '}',
                ObjectSerializer::toPathValue($payment_service),
                $resourcePath
            );
        }
        // path params
        if ($payment_product !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-product' . '}',
                ObjectSerializer::toPathValue($payment_product),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($payment_initiation_body_json)) {
            $_tempBody = $payment_initiation_body_json;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                ['application/json', 'application/xml', 'multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startPaymentAuthorisation
     *
     * Start the authorisation process for a payment initiation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\StartScaprocessResponse|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS
     */
    public function startPaymentAuthorisation($associative_array)
    {
        list($response) = $this->startPaymentAuthorisationWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation startPaymentAuthorisationWithHttpInfo
     *
     * Start the authorisation process for a payment initiation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\StartScaprocessResponse|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function startPaymentAuthorisationWithHttpInfo($associative_array)
    {
        $request = $this->startPaymentAuthorisationRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 201:
                    if ('\BankIO\Sdk\Model\StartScaprocessResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\StartScaprocessResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\StartScaprocessResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\StartScaprocessResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation startPaymentAuthorisationAsync
     *
     * Start the authorisation process for a payment initiation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function startPaymentAuthorisationAsync($associative_array)
    {
        return $this->startPaymentAuthorisationAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startPaymentAuthorisationAsyncWithHttpInfo
     *
     * Start the authorisation process for a payment initiation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function startPaymentAuthorisationAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\StartScaprocessResponse';
        $request = $this->startPaymentAuthorisationRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startPaymentAuthorisation'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function startPaymentAuthorisationRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $payment_service = array_key_exists('payment_service', $associative_array) ? $associative_array['payment_service'] : null;
        $payment_product = array_key_exists('payment_product', $associative_array) ? $associative_array['payment_product'] : null;
        $payment_id = array_key_exists('payment_id', $associative_array) ? $associative_array['payment_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $psu_id = array_key_exists('psu_id', $associative_array) ? $associative_array['psu_id'] : null;
        $psu_id_type = array_key_exists('psu_id_type', $associative_array) ? $associative_array['psu_id_type'] : null;
        $psu_corporate_id = array_key_exists('psu_corporate_id', $associative_array) ? $associative_array['psu_corporate_id'] : null;
        $psu_corporate_id_type = array_key_exists('psu_corporate_id_type', $associative_array) ? $associative_array['psu_corporate_id_type'] : null;
        $tpp_redirect_preferred = array_key_exists('tpp_redirect_preferred', $associative_array) ? $associative_array['tpp_redirect_preferred'] : null;
        $tpp_redirect_uri = array_key_exists('tpp_redirect_uri', $associative_array) ? $associative_array['tpp_redirect_uri'] : null;
        $tpp_nok_redirect_uri = array_key_exists('tpp_nok_redirect_uri', $associative_array) ? $associative_array['tpp_nok_redirect_uri'] : null;
        $tpp_notification_uri = array_key_exists('tpp_notification_uri', $associative_array) ? $associative_array['tpp_notification_uri'] : null;
        $tpp_notification_content_preferred = array_key_exists('tpp_notification_content_preferred', $associative_array) ? $associative_array['tpp_notification_content_preferred'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;
        $unknown_base_type = array_key_exists('unknown_base_type', $associative_array) ? $associative_array['unknown_base_type'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling startPaymentAuthorisation'
            );
        }
        // verify the required parameter 'payment_service' is set
        if ($payment_service === null || (is_array($payment_service) && count($payment_service) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_service when calling startPaymentAuthorisation'
            );
        }
        // verify the required parameter 'payment_product' is set
        if ($payment_product === null || (is_array($payment_product) && count($payment_product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_product when calling startPaymentAuthorisation'
            );
        }
        // verify the required parameter 'payment_id' is set
        if ($payment_id === null || (is_array($payment_id) && count($payment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_id when calling startPaymentAuthorisation'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling startPaymentAuthorisation'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling PaymentInitiationServicePISApi.startPaymentAuthorisation, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/{payment-service}/{payment-product}/{paymentId}/authorisations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($psu_id !== null) {
            $headerParams['PSU-ID'] = ObjectSerializer::toHeaderValue($psu_id);
        }
        // header params
        if ($psu_id_type !== null) {
            $headerParams['PSU-ID-Type'] = ObjectSerializer::toHeaderValue($psu_id_type);
        }
        // header params
        if ($psu_corporate_id !== null) {
            $headerParams['PSU-Corporate-ID'] = ObjectSerializer::toHeaderValue($psu_corporate_id);
        }
        // header params
        if ($psu_corporate_id_type !== null) {
            $headerParams['PSU-Corporate-ID-Type'] = ObjectSerializer::toHeaderValue($psu_corporate_id_type);
        }
        // header params
        if ($tpp_redirect_preferred !== null) {
            $headerParams['TPP-Redirect-Preferred'] = ObjectSerializer::toHeaderValue($tpp_redirect_preferred);
        }
        // header params
        if ($tpp_redirect_uri !== null) {
            $headerParams['TPP-Redirect-URI'] = ObjectSerializer::toHeaderValue($tpp_redirect_uri);
        }
        // header params
        if ($tpp_nok_redirect_uri !== null) {
            $headerParams['TPP-Nok-Redirect-URI'] = ObjectSerializer::toHeaderValue($tpp_nok_redirect_uri);
        }
        // header params
        if ($tpp_notification_uri !== null) {
            $headerParams['TPP-Notification-URI'] = ObjectSerializer::toHeaderValue($tpp_notification_uri);
        }
        // header params
        if ($tpp_notification_content_preferred !== null) {
            $headerParams['TPP-Notification-Content-Preferred'] = ObjectSerializer::toHeaderValue($tpp_notification_content_preferred);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($payment_service !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-service' . '}',
                ObjectSerializer::toPathValue($payment_service),
                $resourcePath
            );
        }
        // path params
        if ($payment_product !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-product' . '}',
                ObjectSerializer::toPathValue($payment_product),
                $resourcePath
            );
        }
        // path params
        if ($payment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentId' . '}',
                ObjectSerializer::toPathValue($payment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startPaymentInitiationCancellationAuthorisation
     *
     * Start the authorisation process for the cancellation of the addressed payment
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \BankIO\Sdk\Model\StartScaprocessResponse|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS
     */
    public function startPaymentInitiationCancellationAuthorisation($associative_array)
    {
        list($response) = $this->startPaymentInitiationCancellationAuthorisationWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation startPaymentInitiationCancellationAuthorisationWithHttpInfo
     *
     * Start the authorisation process for the cancellation of the addressed payment
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \BankIO\Sdk\Model\StartScaprocessResponse|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function startPaymentInitiationCancellationAuthorisationWithHttpInfo($associative_array)
    {
        $request = $this->startPaymentInitiationCancellationAuthorisationRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 201:
                    if ('\BankIO\Sdk\Model\StartScaprocessResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\StartScaprocessResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\BankIO\Sdk\Model\StartScaprocessResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\StartScaprocessResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation startPaymentInitiationCancellationAuthorisationAsync
     *
     * Start the authorisation process for the cancellation of the addressed payment
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function startPaymentInitiationCancellationAuthorisationAsync($associative_array)
    {
        return $this->startPaymentInitiationCancellationAuthorisationAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startPaymentInitiationCancellationAuthorisationAsyncWithHttpInfo
     *
     * Start the authorisation process for the cancellation of the addressed payment
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function startPaymentInitiationCancellationAuthorisationAsyncWithHttpInfo($associative_array)
    {
        $returnType = '\BankIO\Sdk\Model\StartScaprocessResponse';
        $request = $this->startPaymentInitiationCancellationAuthorisationRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startPaymentInitiationCancellationAuthorisation'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  bool $tpp_redirect_preferred If it equals \&quot;true\&quot;, the TPP prefers a redirect over an embedded SCA approach. If it equals \&quot;false\&quot;, the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled SCA approach, depending on the choice of the SCA procedure by the TPP/PSU. If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the TPP/PSU. (optional)
     * @param  string $tpp_redirect_uri URI of the TPP, where the transaction flow shall be redirected to after a Redirect.  Mandated for the Redirect SCA Approach, specifically  when TPP-Redirect-Preferred equals \&quot;true\&quot;. It is recommended to always use this header field.  **Remark for Future:**  This field might be changed to mandatory in the next version of the specification. (optional)
     * @param  string $tpp_nok_redirect_uri If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case of a negative result of the redirect SCA method. This might be ignored by the ASPSP. (optional)
     * @param  string $tpp_notification_uri URI for the Endpoint of the TPP-API to which the status of the payment initiation should be sent. This header field may by ignored by the ASPSP.  For security reasons, it shall be ensured that the TPP-Notification-URI as introduced above is secured by the TPP eIDAS QWAC used for identification of the TPP. The following applies:  URIs which are provided by TPPs in TPP-Notification-URI shall comply with the domain secured by the eIDAS QWAC certificate of the TPP in the field CN or SubjectAltName of the certificate. Please note that in case of example-TPP.com as certificate entry TPP- Notification-URI like www.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications or notifications.example-TPP.com/xs2a-client/v1/ASPSPidentifcation/mytransaction- id/notifications would be compliant.  Wildcard definitions shall be taken into account for compliance checks by the ASPSP.  ASPSPs may respond with ASPSP-Notification-Support set to false, if the provided URIs do not comply. (optional)
     * @param  string $tpp_notification_content_preferred The string has the form   status&#x3D;X1, ..., Xn  where Xi is one of the constants SCA, PROCESS, LAST and where constants are not repeated. The usage of the constants supports the of following semantics:    SCA: A notification on every change of the scaStatus attribute for all related authorisation processes is preferred by the TPP.    PROCESS: A notification on all changes of consentStatus or transactionStatus attributes is preferred by the TPP.   LAST: Only a notification on the last consentStatus or transactionStatus as available in the XS2A interface is preferred by the TPP.  This header field may be ignored, if the ASPSP does not support resource notification services for the related TPP. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function startPaymentInitiationCancellationAuthorisationRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $payment_service = array_key_exists('payment_service', $associative_array) ? $associative_array['payment_service'] : null;
        $payment_product = array_key_exists('payment_product', $associative_array) ? $associative_array['payment_product'] : null;
        $payment_id = array_key_exists('payment_id', $associative_array) ? $associative_array['payment_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_id = array_key_exists('psu_id', $associative_array) ? $associative_array['psu_id'] : null;
        $psu_id_type = array_key_exists('psu_id_type', $associative_array) ? $associative_array['psu_id_type'] : null;
        $psu_corporate_id = array_key_exists('psu_corporate_id', $associative_array) ? $associative_array['psu_corporate_id'] : null;
        $psu_corporate_id_type = array_key_exists('psu_corporate_id_type', $associative_array) ? $associative_array['psu_corporate_id_type'] : null;
        $tpp_redirect_preferred = array_key_exists('tpp_redirect_preferred', $associative_array) ? $associative_array['tpp_redirect_preferred'] : null;
        $tpp_redirect_uri = array_key_exists('tpp_redirect_uri', $associative_array) ? $associative_array['tpp_redirect_uri'] : null;
        $tpp_nok_redirect_uri = array_key_exists('tpp_nok_redirect_uri', $associative_array) ? $associative_array['tpp_nok_redirect_uri'] : null;
        $tpp_notification_uri = array_key_exists('tpp_notification_uri', $associative_array) ? $associative_array['tpp_notification_uri'] : null;
        $tpp_notification_content_preferred = array_key_exists('tpp_notification_content_preferred', $associative_array) ? $associative_array['tpp_notification_content_preferred'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;
        $unknown_base_type = array_key_exists('unknown_base_type', $associative_array) ? $associative_array['unknown_base_type'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling startPaymentInitiationCancellationAuthorisation'
            );
        }
        // verify the required parameter 'payment_service' is set
        if ($payment_service === null || (is_array($payment_service) && count($payment_service) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_service when calling startPaymentInitiationCancellationAuthorisation'
            );
        }
        // verify the required parameter 'payment_product' is set
        if ($payment_product === null || (is_array($payment_product) && count($payment_product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_product when calling startPaymentInitiationCancellationAuthorisation'
            );
        }
        // verify the required parameter 'payment_id' is set
        if ($payment_id === null || (is_array($payment_id) && count($payment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_id when calling startPaymentInitiationCancellationAuthorisation'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling startPaymentInitiationCancellationAuthorisation'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling PaymentInitiationServicePISApi.startPaymentInitiationCancellationAuthorisation, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/{payment-service}/{payment-product}/{paymentId}/cancellation-authorisations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_id !== null) {
            $headerParams['PSU-ID'] = ObjectSerializer::toHeaderValue($psu_id);
        }
        // header params
        if ($psu_id_type !== null) {
            $headerParams['PSU-ID-Type'] = ObjectSerializer::toHeaderValue($psu_id_type);
        }
        // header params
        if ($psu_corporate_id !== null) {
            $headerParams['PSU-Corporate-ID'] = ObjectSerializer::toHeaderValue($psu_corporate_id);
        }
        // header params
        if ($psu_corporate_id_type !== null) {
            $headerParams['PSU-Corporate-ID-Type'] = ObjectSerializer::toHeaderValue($psu_corporate_id_type);
        }
        // header params
        if ($tpp_redirect_preferred !== null) {
            $headerParams['TPP-Redirect-Preferred'] = ObjectSerializer::toHeaderValue($tpp_redirect_preferred);
        }
        // header params
        if ($tpp_redirect_uri !== null) {
            $headerParams['TPP-Redirect-URI'] = ObjectSerializer::toHeaderValue($tpp_redirect_uri);
        }
        // header params
        if ($tpp_nok_redirect_uri !== null) {
            $headerParams['TPP-Nok-Redirect-URI'] = ObjectSerializer::toHeaderValue($tpp_nok_redirect_uri);
        }
        // header params
        if ($tpp_notification_uri !== null) {
            $headerParams['TPP-Notification-URI'] = ObjectSerializer::toHeaderValue($tpp_notification_uri);
        }
        // header params
        if ($tpp_notification_content_preferred !== null) {
            $headerParams['TPP-Notification-Content-Preferred'] = ObjectSerializer::toHeaderValue($tpp_notification_content_preferred);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($payment_service !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-service' . '}',
                ObjectSerializer::toPathValue($payment_service),
                $resourcePath
            );
        }
        // path params
        if ($payment_product !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-product' . '}',
                ObjectSerializer::toPathValue($payment_product),
                $resourcePath
            );
        }
        // path params
        if ($payment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentId' . '}',
                ObjectSerializer::toPathValue($payment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePaymentCancellationPsuData
     *
     * Update PSU data for payment initiation cancellation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS
     */
    public function updatePaymentCancellationPsuData($associative_array)
    {
        list($response) = $this->updatePaymentCancellationPsuDataWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation updatePaymentCancellationPsuDataWithHttpInfo
     *
     * Update PSU data for payment initiation cancellation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePaymentCancellationPsuDataWithHttpInfo($associative_array)
    {
        $request = $this->updatePaymentCancellationPsuDataRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePaymentCancellationPsuDataAsync
     *
     * Update PSU data for payment initiation cancellation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function updatePaymentCancellationPsuDataAsync($associative_array)
    {
        return $this->updatePaymentCancellationPsuDataAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePaymentCancellationPsuDataAsyncWithHttpInfo
     *
     * Update PSU data for payment initiation cancellation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function updatePaymentCancellationPsuDataAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse';
        $request = $this->updatePaymentCancellationPsuDataRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePaymentCancellationPsuData'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function updatePaymentCancellationPsuDataRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $payment_service = array_key_exists('payment_service', $associative_array) ? $associative_array['payment_service'] : null;
        $payment_product = array_key_exists('payment_product', $associative_array) ? $associative_array['payment_product'] : null;
        $payment_id = array_key_exists('payment_id', $associative_array) ? $associative_array['payment_id'] : null;
        $authorisation_id = array_key_exists('authorisation_id', $associative_array) ? $associative_array['authorisation_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_id = array_key_exists('psu_id', $associative_array) ? $associative_array['psu_id'] : null;
        $psu_id_type = array_key_exists('psu_id_type', $associative_array) ? $associative_array['psu_id_type'] : null;
        $psu_corporate_id = array_key_exists('psu_corporate_id', $associative_array) ? $associative_array['psu_corporate_id'] : null;
        $psu_corporate_id_type = array_key_exists('psu_corporate_id_type', $associative_array) ? $associative_array['psu_corporate_id_type'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;
        $unknown_base_type = array_key_exists('unknown_base_type', $associative_array) ? $associative_array['unknown_base_type'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling updatePaymentCancellationPsuData'
            );
        }
        // verify the required parameter 'payment_service' is set
        if ($payment_service === null || (is_array($payment_service) && count($payment_service) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_service when calling updatePaymentCancellationPsuData'
            );
        }
        // verify the required parameter 'payment_product' is set
        if ($payment_product === null || (is_array($payment_product) && count($payment_product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_product when calling updatePaymentCancellationPsuData'
            );
        }
        // verify the required parameter 'payment_id' is set
        if ($payment_id === null || (is_array($payment_id) && count($payment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_id when calling updatePaymentCancellationPsuData'
            );
        }
        // verify the required parameter 'authorisation_id' is set
        if ($authorisation_id === null || (is_array($authorisation_id) && count($authorisation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorisation_id when calling updatePaymentCancellationPsuData'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling updatePaymentCancellationPsuData'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling PaymentInitiationServicePISApi.updatePaymentCancellationPsuData, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/{payment-service}/{payment-product}/{paymentId}/cancellation-authorisations/{authorisationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_id !== null) {
            $headerParams['PSU-ID'] = ObjectSerializer::toHeaderValue($psu_id);
        }
        // header params
        if ($psu_id_type !== null) {
            $headerParams['PSU-ID-Type'] = ObjectSerializer::toHeaderValue($psu_id_type);
        }
        // header params
        if ($psu_corporate_id !== null) {
            $headerParams['PSU-Corporate-ID'] = ObjectSerializer::toHeaderValue($psu_corporate_id);
        }
        // header params
        if ($psu_corporate_id_type !== null) {
            $headerParams['PSU-Corporate-ID-Type'] = ObjectSerializer::toHeaderValue($psu_corporate_id_type);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($payment_service !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-service' . '}',
                ObjectSerializer::toPathValue($payment_service),
                $resourcePath
            );
        }
        // path params
        if ($payment_product !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-product' . '}',
                ObjectSerializer::toPathValue($payment_product),
                $resourcePath
            );
        }
        // path params
        if ($payment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentId' . '}',
                ObjectSerializer::toPathValue($payment_id),
                $resourcePath
            );
        }
        // path params
        if ($authorisation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'authorisationId' . '}',
                ObjectSerializer::toPathValue($authorisation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePaymentPsuData
     *
     * Update PSU data for payment initiation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type unknown_base_type (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS
     */
    public function updatePaymentPsuData($associative_array)
    {
        list($response) = $this->updatePaymentPsuDataWithHttpInfo($associative_array);
        return $response;
    }

    /**
     * Operation updatePaymentPsuDataWithHttpInfo
     *
     * Update PSU data for payment initiation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \BankIO\Sdk\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse|\BankIO\Sdk\Model\Error400NGPIS|\BankIO\Sdk\Model\Error401NGPIS|\BankIO\Sdk\Model\Error403NGPIS|\BankIO\Sdk\Model\Error404NGPIS|\BankIO\Sdk\Model\Error405NGPIS|\BankIO\Sdk\Model\Error409NGPIS, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePaymentPsuDataWithHttpInfo($associative_array)
    {
        $request = $this->updatePaymentPsuDataRequest($associative_array);

        try {
            // $options = $this->createHttpClientOption();
            try {
                $response = $this->client->sendRequest($request);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\BankIO\Sdk\Model\Error400NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error400NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\BankIO\Sdk\Model\Error401NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error401NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\BankIO\Sdk\Model\Error403NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error403NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\BankIO\Sdk\Model\Error404NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error404NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\BankIO\Sdk\Model\Error405NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error405NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\BankIO\Sdk\Model\Error409NGPIS' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\BankIO\Sdk\Model\Error409NGPIS', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error400NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error401NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error403NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error404NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error405NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\BankIO\Sdk\Model\Error409NGPIS',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePaymentPsuDataAsync
     *
     * Update PSU data for payment initiation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function updatePaymentPsuDataAsync($associative_array)
    {
        return $this->updatePaymentPsuDataAsyncWithHttpInfo($associative_array)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePaymentPsuDataAsyncWithHttpInfo
     *
     * Update PSU data for payment initiation
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Http\Promise\Promise
     */
    public function updatePaymentPsuDataAsyncWithHttpInfo($associative_array)
    {
        $returnType = 'OneOfUpdatePsuIdenticationResponseUpdatePsuAuthenticationResponseSelectPsuAuthenticationMethodResponseScaStatusResponseAuthorisationConfirmationResponse';
        $request = $this->updatePaymentPsuDataRequest($associative_array);

        // $this->createHttpClientOption()
        return $this->client
            ->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePaymentPsuData'
     *
     * Note: the input parameter is an associative array with the keys listed as the parameter name below
     *
     * @param  string $organisation This identification is denoting the addressed bankIO organisation. The organisation is the \&quot;name\&quot; attribute of the organisation structure.  Its value is constant at least throughout the lifecycle of a given consent. (required)
     * @param  string $payment_service Payment service:  Possible values are: * payments * bulk-payments * periodic-payments (required)
     * @param  string $payment_product The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT). The ASPSP will publish which of the payment products/endpoints will be supported.  The following payment products are supported:   - sepa-credit-transfers   - instant-sepa-credit-transfers   - target-2-payments   - cross-border-credit-transfers   - pain.001-sepa-credit-transfers   - pain.001-instant-sepa-credit-transfers   - pain.001-target-2-payments   - pain.001-cross-border-credit-transfers  **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,  the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.  Further XML schemes might be supported by some communities.  **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.  There are plenty of country specificic scheme variants. (required)
     * @param  string $payment_id Resource identification of the generated payment initiation resource. (required)
     * @param  string $authorisation_id Resource identification of the related SCA. (required)
     * @param  string $x_request_id ID of the request, unique to the call, as determined by the initiating party. (required)
     * @param  string $digest Is contained if and only if the \&quot;Signature\&quot; element is contained in the header of the request. (optional)
     * @param  string $signature A signature of the request by the TPP on application level. This might be mandated by ASPSP. (optional)
     * @param  string $tpp_signature_certificate The certificate used for signing the request, in base64 encoding.  Must be contained if a signature is contained. (optional)
     * @param  string $psu_id Client ID of the PSU in the ASPSP client interface.   Might be mandated in the ASPSP&#39;s documentation.  It might be contained even if an OAuth2 based authentication was performed in a pre-step or an OAuth2 based SCA was performed in an preceding AIS service in the same session. In this case the ASPSP might check whether PSU-ID and token match,  according to ASPSP documentation. (optional)
     * @param  string $psu_id_type Type of the PSU-ID, needed in scenarios where PSUs have several PSU-IDs as access possibility.  In this case, the mean and use are then defined in the ASPSP’s documentation. (optional)
     * @param  string $psu_corporate_id Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_corporate_id_type Might be mandated in the ASPSP&#39;s documentation. Only used in a corporate context. (optional)
     * @param  string $psu_ip_address The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP. (optional)
     * @param  string $psu_ip_port The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available. (optional)
     * @param  string $psu_accept The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_charset The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_encoding The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_accept_language The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available. (optional)
     * @param  string $psu_user_agent The forwarded Agent header field of the HTTP request between PSU and TPP, if available. (optional)
     * @param  string $psu_http_method HTTP method used at the PSU ? TPP interface, if available. Valid values are: * GET * POST * PUT * PATCH * DELETE (optional)
     * @param  string $psu_device_id UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available. UUID identifies either a device or a device dependant application installation. In case of an installation identification this ID needs to be unaltered until removal from device. (optional)
     * @param  string $psu_geo_location The forwarded Geo Location of the corresponding http request between PSU and TPP if available. (optional)
     * @param  \BankIO\Sdk\Model\UNKNOWN_BASE_TYPE $unknown_base_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \Psr\Http\Message\RequestInterface
     */
    protected function updatePaymentPsuDataRequest($associative_array)
    {
        // unbox the parameters from the associative array
        $organisation = array_key_exists('organisation', $associative_array) ? $associative_array['organisation'] : null;
        $payment_service = array_key_exists('payment_service', $associative_array) ? $associative_array['payment_service'] : null;
        $payment_product = array_key_exists('payment_product', $associative_array) ? $associative_array['payment_product'] : null;
        $payment_id = array_key_exists('payment_id', $associative_array) ? $associative_array['payment_id'] : null;
        $authorisation_id = array_key_exists('authorisation_id', $associative_array) ? $associative_array['authorisation_id'] : null;
        $x_request_id = array_key_exists('x_request_id', $associative_array) ? $associative_array['x_request_id'] : null;
        $digest = array_key_exists('digest', $associative_array) ? $associative_array['digest'] : null;
        $signature = array_key_exists('signature', $associative_array) ? $associative_array['signature'] : null;
        $tpp_signature_certificate = array_key_exists('tpp_signature_certificate', $associative_array) ? $associative_array['tpp_signature_certificate'] : null;
        $psu_id = array_key_exists('psu_id', $associative_array) ? $associative_array['psu_id'] : null;
        $psu_id_type = array_key_exists('psu_id_type', $associative_array) ? $associative_array['psu_id_type'] : null;
        $psu_corporate_id = array_key_exists('psu_corporate_id', $associative_array) ? $associative_array['psu_corporate_id'] : null;
        $psu_corporate_id_type = array_key_exists('psu_corporate_id_type', $associative_array) ? $associative_array['psu_corporate_id_type'] : null;
        $psu_ip_address = array_key_exists('psu_ip_address', $associative_array) ? $associative_array['psu_ip_address'] : null;
        $psu_ip_port = array_key_exists('psu_ip_port', $associative_array) ? $associative_array['psu_ip_port'] : null;
        $psu_accept = array_key_exists('psu_accept', $associative_array) ? $associative_array['psu_accept'] : null;
        $psu_accept_charset = array_key_exists('psu_accept_charset', $associative_array) ? $associative_array['psu_accept_charset'] : null;
        $psu_accept_encoding = array_key_exists('psu_accept_encoding', $associative_array) ? $associative_array['psu_accept_encoding'] : null;
        $psu_accept_language = array_key_exists('psu_accept_language', $associative_array) ? $associative_array['psu_accept_language'] : null;
        $psu_user_agent = array_key_exists('psu_user_agent', $associative_array) ? $associative_array['psu_user_agent'] : null;
        $psu_http_method = array_key_exists('psu_http_method', $associative_array) ? $associative_array['psu_http_method'] : null;
        $psu_device_id = array_key_exists('psu_device_id', $associative_array) ? $associative_array['psu_device_id'] : null;
        $psu_geo_location = array_key_exists('psu_geo_location', $associative_array) ? $associative_array['psu_geo_location'] : null;
        $unknown_base_type = array_key_exists('unknown_base_type', $associative_array) ? $associative_array['unknown_base_type'] : null;

        // verify the required parameter 'organisation' is set
        if ($organisation === null || (is_array($organisation) && count($organisation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organisation when calling updatePaymentPsuData'
            );
        }
        // verify the required parameter 'payment_service' is set
        if ($payment_service === null || (is_array($payment_service) && count($payment_service) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_service when calling updatePaymentPsuData'
            );
        }
        // verify the required parameter 'payment_product' is set
        if ($payment_product === null || (is_array($payment_product) && count($payment_product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_product when calling updatePaymentPsuData'
            );
        }
        // verify the required parameter 'payment_id' is set
        if ($payment_id === null || (is_array($payment_id) && count($payment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $payment_id when calling updatePaymentPsuData'
            );
        }
        // verify the required parameter 'authorisation_id' is set
        if ($authorisation_id === null || (is_array($authorisation_id) && count($authorisation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorisation_id when calling updatePaymentPsuData'
            );
        }
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling updatePaymentPsuData'
            );
        }
        if ($psu_geo_location !== null && !preg_match("/GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/", $psu_geo_location)) {
            throw new \InvalidArgumentException("invalid value for \"psu_geo_location\" when calling PaymentInitiationServicePISApi.updatePaymentPsuData, must conform to the pattern /GEO:-?[0-9]{1,2}\\.[0-9]{6};-?[0-9]{1,3}\\.[0-9]{6}/.");
        }


        $resourcePath = '/api/org/{organisation}/v1/{payment-service}/{payment-product}/{paymentId}/authorisations/{authorisationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($digest !== null) {
            $headerParams['Digest'] = ObjectSerializer::toHeaderValue($digest);
        }
        // header params
        if ($signature !== null) {
            $headerParams['Signature'] = ObjectSerializer::toHeaderValue($signature);
        }
        // header params
        if ($tpp_signature_certificate !== null) {
            $headerParams['TPP-Signature-Certificate'] = ObjectSerializer::toHeaderValue($tpp_signature_certificate);
        }
        // header params
        if ($psu_id !== null) {
            $headerParams['PSU-ID'] = ObjectSerializer::toHeaderValue($psu_id);
        }
        // header params
        if ($psu_id_type !== null) {
            $headerParams['PSU-ID-Type'] = ObjectSerializer::toHeaderValue($psu_id_type);
        }
        // header params
        if ($psu_corporate_id !== null) {
            $headerParams['PSU-Corporate-ID'] = ObjectSerializer::toHeaderValue($psu_corporate_id);
        }
        // header params
        if ($psu_corporate_id_type !== null) {
            $headerParams['PSU-Corporate-ID-Type'] = ObjectSerializer::toHeaderValue($psu_corporate_id_type);
        }
        // header params
        if ($psu_ip_address !== null) {
            $headerParams['PSU-IP-Address'] = ObjectSerializer::toHeaderValue($psu_ip_address);
        }
        // header params
        if ($psu_ip_port !== null) {
            $headerParams['PSU-IP-Port'] = ObjectSerializer::toHeaderValue($psu_ip_port);
        }
        // header params
        if ($psu_accept !== null) {
            $headerParams['PSU-Accept'] = ObjectSerializer::toHeaderValue($psu_accept);
        }
        // header params
        if ($psu_accept_charset !== null) {
            $headerParams['PSU-Accept-Charset'] = ObjectSerializer::toHeaderValue($psu_accept_charset);
        }
        // header params
        if ($psu_accept_encoding !== null) {
            $headerParams['PSU-Accept-Encoding'] = ObjectSerializer::toHeaderValue($psu_accept_encoding);
        }
        // header params
        if ($psu_accept_language !== null) {
            $headerParams['PSU-Accept-Language'] = ObjectSerializer::toHeaderValue($psu_accept_language);
        }
        // header params
        if ($psu_user_agent !== null) {
            $headerParams['PSU-User-Agent'] = ObjectSerializer::toHeaderValue($psu_user_agent);
        }
        // header params
        if ($psu_http_method !== null) {
            $headerParams['PSU-Http-Method'] = ObjectSerializer::toHeaderValue($psu_http_method);
        }
        // header params
        if ($psu_device_id !== null) {
            $headerParams['PSU-Device-ID'] = ObjectSerializer::toHeaderValue($psu_device_id);
        }
        // header params
        if ($psu_geo_location !== null) {
            $headerParams['PSU-Geo-Location'] = ObjectSerializer::toHeaderValue($psu_geo_location);
        }

        // path params
        if ($organisation !== null) {
            $resourcePath = str_replace(
                '{' . 'organisation' . '}',
                ObjectSerializer::toPathValue($organisation),
                $resourcePath
            );
        }
        // path params
        if ($payment_service !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-service' . '}',
                ObjectSerializer::toPathValue($payment_service),
                $resourcePath
            );
        }
        // path params
        if ($payment_product !== null) {
            $resourcePath = str_replace(
                '{' . 'payment-product' . '}',
                ObjectSerializer::toPathValue($payment_product),
                $resourcePath
            );
        }
        // path params
        if ($payment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'paymentId' . '}',
                ObjectSerializer::toPathValue($payment_id),
                $resourcePath
            );
        }
        // path params
        if ($authorisation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'authorisationId' . '}',
                ObjectSerializer::toPathValue($authorisation_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($unknown_base_type)) {
            $_tempBody = $unknown_base_type;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/problem+json', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/problem+json', ],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $builder = new MultipartStreamBuilder($streamFactory);
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $builder->addResource($formParamName, $formParamValueItem);
                    }
                }
                // for HTTP post (form)
                $httpBody = $builder->build();

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = http_build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = http_build_query($queryParams);
        return $this->messageFactory->createRequest(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
        }

        return $options;
    }

    /**
    * Safely opens a PHP stream resource using a filename.
    *
    * When fopen fails, PHP normally raises a warning. This function adds an
    * error handler that checks for errors and throws an exception instead.
    *
    * @param string $filename File to open
    * @param string $mode     Mode used to open the file
    *
    * @return resource
    *
    * @throws \RuntimeException if the file cannot be opened
    */
    protected function try_fopen(string $filename, string $mode)
    {
        $ex = null;
        set_error_handler(function (int $errno, string $errstr) use ($filename, $mode, &$ex) {
            $ex = new \RuntimeException(sprintf(
                'Unable to open %s using mode %s: %s',
                $filename,
                $mode,
                $errstr
            ));
        });

        /** @var resource $handle */
        $handle = fopen($filename, $mode);
        restore_error_handler();

        if ($ex) {
            /** @var $ex \RuntimeException */
            throw $ex;
        }

        return $handle;
    }
}
